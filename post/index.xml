<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on Yen&#39;s部落格</title>
    <link>https://yen0304.github.io/post/</link>
    <description>Recent content in Posts on Yen&#39;s部落格</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-tw</language>
    <lastBuildDate>Sun, 06 Feb 2022 00:00:00 +0000</lastBuildDate><atom:link href="https://yen0304.github.io/post/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Java筆記(1)泛型、集合與檔案操作</title>
      <link>https://yen0304.github.io/p/java%E7%AD%86%E8%A8%981%E6%B3%9B%E5%9E%8B%E9%9B%86%E5%90%88%E8%88%87%E6%AA%94%E6%A1%88%E6%93%8D%E4%BD%9C/</link>
      <pubDate>Sun, 06 Feb 2022 00:00:00 +0000</pubDate>
      
      <guid>https://yen0304.github.io/p/java%E7%AD%86%E8%A8%981%E6%B3%9B%E5%9E%8B%E9%9B%86%E5%90%88%E8%88%87%E6%AA%94%E6%A1%88%E6%93%8D%E4%BD%9C/</guid>
      <description>泛型(Generics)  泛型是多型(polymorphism)的一種技巧 當編譯期間無法確定程式碼的撰寫方式，而是依照執行期間的狀況而決定 不用因為資料型別的限制而實作多種方法，只需要一種方法即可 定義「安全的」泛型類別(Genericsclass)，泛型提供編譯時期檢查  泛型用&amp;lt;參數(自定義)&amp;gt;表示，也可以像一般變數一樣傳進多個參數進去，
泛型通常最常使用的情況是，當不確定使用的參數的時候，不用因為資料型別的限制而實作許多方法。
public class Foo&amp;lt;T&amp;gt;{ private T f; } public class Foo&amp;lt;T1,T2&amp;gt;{ private T1 fl; private T2 f2; } 通配字元(Wildcard)  共變性 繼承於List的子類別或實作List介面的類別 List的父類別 通配字元(?)不能當作宣告方法的型別，必須是變數名稱  使用方式比泛型&amp;lt;&amp;gt;多了一個?
使用範例：
Doo&amp;lt;? extends List &amp;gt; // 代表?的類別必須是繼承於List的子型別或是實作List介面的類別 Doo&amp;lt;? super List &amp;gt; //必須是List的父類別 Foo&amp;lt;? extends List&amp;gt; fooObj = new Foo&amp;lt;ArrrayList&amp;gt;(); //因為ArrayList是List子型別，才可以這樣使用。  Foo&amp;lt;? super ArrayList&amp;gt; fooObj = new Foo&amp;lt;List&amp;gt;(); //代表要是Array的父類別才可以使用  ArrayList 
集合(COLLECTIONS)  將許多同⼀種資料型態的物件集合在⼀起 比陣列更有彈性好處理  List(有序集合)  將物件依序存放，並依序取出 可以存放重複的物件  官方API文件：https://docs.</description>
    </item>
    
    <item>
      <title>Docker筆記(2)-Dockerfile語法使用</title>
      <link>https://yen0304.github.io/p/docker%E7%AD%86%E8%A8%982-dockerfile%E8%AA%9E%E6%B3%95%E4%BD%BF%E7%94%A8/</link>
      <pubDate>Sat, 05 Feb 2022 00:00:00 +0000</pubDate>
      
      <guid>https://yen0304.github.io/p/docker%E7%AD%86%E8%A8%982-dockerfile%E8%AA%9E%E6%B3%95%E4%BD%BF%E7%94%A8/</guid>
      <description>Docekrfile使用觀念 常用Linux指令    MacOS / Linux 指令 說明 範例     exit 離開 exit   pwd 取得目前的路徑 pwd   ls 取得當前資料夾與檔案名稱 ls   cd 切換目錄 cd ~   touch 建立檔案 touch demo.html   mkdir 建立資料夾 mkdir demo   rm 刪除檔案 rm demo.html   cp 複製檔案 cp demo.html demo1.html   scp 在不同的 Linux 主機之間複製檔案 scp user_name@riverye.com:/home/data/考試100分.pdf ~/Desktop   mv 移動檔案 mv demo1.</description>
    </item>
    
    <item>
      <title>Docker筆記(1)-基本</title>
      <link>https://yen0304.github.io/p/docker%E7%AD%86%E8%A8%981-%E5%9F%BA%E6%9C%AC/</link>
      <pubDate>Fri, 04 Feb 2022 00:00:00 +0000</pubDate>
      
      <guid>https://yen0304.github.io/p/docker%E7%AD%86%E8%A8%981-%E5%9F%BA%E6%9C%AC/</guid>
      <description>Docker基本 參考來源：
https://hahow.in/courses/5df27f1fa5ee510022a08500/
https://blog.csdn.net/qq_21197507/article/details/115071715
https://github.com/twtrubiks/docker-tutorial
什麼是Docker docker是一種容器化技術，問題的起源在於在多個APP在同一台主機的同一個系統上運行，只要有問題發生，所有APP會受影響，所有演變成了使用多個主機來完成（傳統模式），但這樣耗費量還是很大，所以就出現了虛擬機（VM模式），就可以達到保護功能，同時用一個主機就可以完成，但這些虛擬機在系統資源（VM、OS）的耗費量還是非常大，所以出現了Docker（容器模式），使用軟體的虛擬的空間來完成。
 
Docker三大功用  簡化部署流程  在部署運行環境時，常常要進行環境安安裝，或是安裝指令，耗時又常常出錯，Docker可以把這些用指令變成程式部署包
 跨平台部署  無論在什麼系統下使用Docker的部署包都可以運行
 建立乾淨測試環境  將測試資料、資料庫安裝、安裝指令打包成資料庫部署包
當有了城市以及資料庫部署包之後，就可以快速運行全新的環境，也可以做安靜的安裝跟清空，不用擔心有殘留檔案的問題
 
名詞解釋   鏡像（image）
映像檔，可以把它想成是以前我們在玩 VM 的 Guest OS（ 安裝在虛擬機上的作業系統 ）。
Image 是唯讀（ R\O ）
  容器（container） Docker利用容器技術，獨立運行一個或者一組應用， 通過鏡像來創建的 啟動，停止，刪除，基本命令！ 就目前可以把這個容器理解為一個建議的linux系統
  倉庫（repository） 存放鏡像(image)的地方，可以把它想成類似 GitHub，裡面存放了非常多的 Image ，可在 Docker Hub 中查看。
  安裝Docker 直接到官網無腦安裝docker-desktop（也可以安裝Docker ToolBox）：
https://www.docker.com/products/docker-desktop
確認安裝
docker --version docker-compose --version 終端機結果
➜ ~ docker --version docker-compose --version Docker version 20.</description>
    </item>
    
    <item>
      <title>JWT(JSON Web Token)原理介紹&amp;實作JWS</title>
      <link>https://yen0304.github.io/p/jwtjson-web-token%E5%8E%9F%E7%90%86%E4%BB%8B%E7%B4%B9%E5%AF%A6%E4%BD%9Cjws/</link>
      <pubDate>Wed, 02 Feb 2022 00:00:00 +0000</pubDate>
      
      <guid>https://yen0304.github.io/p/jwtjson-web-token%E5%8E%9F%E7%90%86%E4%BB%8B%E7%B4%B9%E5%AF%A6%E4%BD%9Cjws/</guid>
      <description>JWT(JSON Web Token) — 原理介紹&amp;amp;實作JWS 現在網上大多數介紹JWT的文章實際介紹的都是JWS(JSON Web Signature),也往往導致了人們對於JWT的誤解，但是JWT並不等於JWS，JWS只是JWT的一種實現，除了JWS外，JWE(JSON Web Encryption)也是JWT的一種實現
原文網址：https://kknews.cc/code/ok4j92o.html
什麼是JWT JWT 的全名是 JSON Web Token，是一種基於 JSON 的開放標準(RFC 7519)，它定義了一種簡潔(compact)且自包含(self-contained)的方式，用於在雙方之間安全地將訊息作為 JSON 物件傳輸。而這個訊息是經過數位簽章(Digital Signature)，因此可以被驗證及信任。可以使用 密碼(經過 HMAC 演算法) 或用一對 公鑰/私鑰(經過 RSA 或 ECDSA 演算法) 來對 JWT 進行簽章。
什麼情況適合使用 JWT  授權(Authorization)：這是很常見 JWT 的使用方式，例如使用者從 Client 端登入後，該使用者再次對 Server 端發送請求的時候，會夾帶著 JWT，允許使用者存取該 token 有權限的資源。單一登錄(Single Sign On)是當今廣泛使用 JWT 的功能之一，因為它的成本較小並且可以在不同的網域(domain)中輕鬆使用。 訊息交換(Information Exchange)：JWT 可以透過公鑰/私鑰來做簽章，讓我們可以知道是誰發送這個 JWT，此外，由於簽章是使用 header 和 payload 計算的，因此還可以驗證內容是否遭到篡改。  環境設置 JDK版本：17
Jsonwebtoken套件 透過這個套件能更方便的創建、完成驗證 JWT，java11是沒有辦法安裝0.9.x以下的版本，在寫法上也略有些不同，所以安裝了0.11.2。
Maven &amp;lt;!--jwt--&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;io.jsonwebtoken&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;jjwt-api&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;0.</description>
    </item>
    
    <item>
      <title>GIT學習筆記(3)－多人協作、分支衝突</title>
      <link>https://yen0304.github.io/p/git%E5%AD%B8%E7%BF%92%E7%AD%86%E8%A8%983%E5%A4%9A%E4%BA%BA%E5%8D%94%E4%BD%9C%E5%88%86%E6%94%AF%E8%A1%9D%E7%AA%81/</link>
      <pubDate>Sun, 16 Jan 2022 00:00:00 +0000</pubDate>
      
      <guid>https://yen0304.github.io/p/git%E5%AD%B8%E7%BF%92%E7%AD%86%E8%A8%983%E5%A4%9A%E4%BA%BA%E5%8D%94%E4%BD%9C%E5%88%86%E6%94%AF%E8%A1%9D%E7%AA%81/</guid>
      <description>GIT學習筆記(3)－多人協作、分支衝突 前言 在看工作的時候，發現很多公司都希望擁有git的經驗，雖然有過使用Github Desktop的經驗，但是還是想知道背後的原理，所以就開始上網查資料學習了。
可以參考這位六角學院的老師文章還有YT影片，實在是免費又大碗（淚。
發Github PR(pull request)請求流程 何謂PR PR可以幫助我們修改別人的遠端數據庫的程式碼，並發起一個PR到別人的遠端數據庫，審核過了就可以成功把修改正式到別人的repo了
例如：
在 GitHub 上看到別人的 CODE 有問題，想幫他修改並提交讓他更新時，就得學會如何發 PR (pull request)，發完之後別人覺得不錯，他就會commit到你剛剛發起的PR commit。
在Github發起PR 在這裡可以有一個六角學院所提供的資源，讓我們練習PR，首先到連結頁面後，可以看到Fork，點擊
 
接著就會跳到我們的數據庫，這時，用clone指令把檔案下載下來
 
接著在創建檔案，並且commit+上傳
 
這裡我是用ssh的方式上傳，成功後可以在網頁上看到：
 
接著到自己的數據庫，選擇Pull request之後
 
在按下Create pull request，下面也可以填PR的名字，還有要提交給對方的留言。
接下來到對方的repo看到我們提交的pr後，就代表成功了，剩下就只剩對方審核commit了
 
衝突 衝突就是指，分支的commit跟master的commit都動到同一行code的時候，在合併分支時就會有衝突，
本地衝突情境  
情況製作好後，直接merge看看有什麼變化：
終端機出現：
➜ gitTest git:(master) ✗ git commit -m &amp;#34;修改標題master&amp;#34; [master d02ff9a] 修改標題master 1 file changed, 1 insertion(+), 1 deletion(-) ➜ gitTest git:(master) git merge dev 自動合併 index.</description>
    </item>
    
    <item>
      <title>GIT學習筆記(2)－分支、還原</title>
      <link>https://yen0304.github.io/p/git%E5%AD%B8%E7%BF%92%E7%AD%86%E8%A8%982%E5%88%86%E6%94%AF%E9%82%84%E5%8E%9F/</link>
      <pubDate>Sat, 15 Jan 2022 00:00:00 +0000</pubDate>
      
      <guid>https://yen0304.github.io/p/git%E5%AD%B8%E7%BF%92%E7%AD%86%E8%A8%982%E5%88%86%E6%94%AF%E9%82%84%E5%8E%9F/</guid>
      <description>GIT學習筆記(2)－分支、還原、協作 前言 在看工作的時候，發現很多公司都希望擁有git的經驗，雖然有過使用Github Desktop的經驗，但是還是想知道背後的原理，所以就開始上網查資料學習了。
可以參考這位六角學院的老師文章還有YT影片，實在是免費又大碗（淚。
HEAD指標 HEAD就是目前指向的版本狀態，他可以指向到分支或是commit
所以要回到先前的commit的話：
查詢commit版本 1.透過 git log來看所有commit
 
在每個 commit 旁邊的亂數就是SHA-1 值
移動HEAD 要回到最初始的時後，使用git checkout &amp;lt;SHA-1值&amp;gt;，
 
這時候到本地目錄查看，其實檔案都回到了該HEAD移動的commit版本。
接著可以到sourcetree查看，可以看到HEAD移動到了剛剛指定的commit版本
 
Sourcetree移動HEAD 如果想要sourcetrr移動HEAD的話，在想要過去的commit點擊兩下就可以了
 
按下ok之後就可以看到檔案被加進去、HEAD也跟著移動了
回到最新的版本 如果想要回到最新的commit，使用
git checkout master 就可以了
分支 分支可以說是git的重頭戲了，分支的好處，就是每一條線都各司其職，做完事後，再將兩條線的功能合併，並部署上線。
舉個分支個例子，例如公司在遠端伺服器上傳了主線(origin master)，在做beta但是不想污染上線的程式碼，這時候就需要分支做beta測試等等。
大概是這些概念
建立分支(git branch) git branch &amp;lt;分支名稱&amp;gt; 在終端機輸入git branch dev後，就可以從sourcetree的commit也多了一個dev
 
接下來再
把HEAD移到分支(git checkout) git checkout &amp;lt;分支名稱&amp;gt; 可以用git branch查看
可以看到下面圖片sourcetree（左），終端機（右）的*號都移到了dev的位置。
圈圈、*號所代表的是目前git checkout位置（HEAD）
 
接著新增檔案index2.html並直接commit來看看變化：
➜ gitTest git:(dev) touch index2.</description>
    </item>
    
    <item>
      <title>GIT學習筆記－從初始化到上傳至遠端數據庫</title>
      <link>https://yen0304.github.io/p/git%E5%AD%B8%E7%BF%92%E7%AD%86%E8%A8%98%E5%BE%9E%E5%88%9D%E5%A7%8B%E5%8C%96%E5%88%B0%E4%B8%8A%E5%82%B3%E8%87%B3%E9%81%A0%E7%AB%AF%E6%95%B8%E6%93%9A%E5%BA%AB/</link>
      <pubDate>Fri, 14 Jan 2022 00:00:00 +0000</pubDate>
      
      <guid>https://yen0304.github.io/p/git%E5%AD%B8%E7%BF%92%E7%AD%86%E8%A8%98%E5%BE%9E%E5%88%9D%E5%A7%8B%E5%8C%96%E5%88%B0%E4%B8%8A%E5%82%B3%E8%87%B3%E9%81%A0%E7%AB%AF%E6%95%B8%E6%93%9A%E5%BA%AB/</guid>
      <description>GIT學習筆記－從初始化到上傳至遠端數據庫 前言 在看工作的時候，發現很多公司都希望擁有git的經驗，雖然有過使用Github Desktop的經驗，但是還是想知道背後的原理，所以就開始上網查資料學習了。
可以參考這位六角學院的老師文章還有YT影片，實在是免費又大碗（淚。
安裝＆測試 用終端機使用brew安裝git：
Install command:
brew install git 測試：
打開終端機，輸入 git --version
➜ ~ git --version git version 2.34.1 就代表安裝成功了
Git基礎操作 首先這邊學習到終端機的使用，可以快速的移動到專案資料夾，
設定個人資訊 git config --global user.name &amp;#34;您的姓名&amp;#34; git config --global user.email &amp;#34;您的Email&amp;#34; 查詢設定是否成功 git config --list 成功顯示之後按下q離開
新建數據庫(Repository) 在電腦新增資料夾後，透過cd前往，在執行git指令$ git init，
$ git init 接著到資料夾，並顯示隱藏檔案，就會看到.git資料夾了。
接著到了
版控流程  開新資料夾，git init 建立數據庫 新增一個 index.html 檔案  接著輸入git status
到這裡應該會出現：
 結果 
可以看到終端機告訴我們；
➜ gitTest git:(master) git status 位於分支 master 尚無提交 未追蹤的檔案: （使用 &amp;#34;git add &amp;lt;檔案&amp;gt;.</description>
    </item>
    
    <item>
      <title>SpringBoot學習筆記-單元測試(4)-使用Mockito來減少單元測試中的Bean依賴</title>
      <link>https://yen0304.github.io/p/springboot%E5%AD%B8%E7%BF%92%E7%AD%86%E8%A8%98-%E5%96%AE%E5%85%83%E6%B8%AC%E8%A9%A64-%E4%BD%BF%E7%94%A8mockito%E4%BE%86%E6%B8%9B%E5%B0%91%E5%96%AE%E5%85%83%E6%B8%AC%E8%A9%A6%E4%B8%AD%E7%9A%84bean%E4%BE%9D%E8%B3%B4/</link>
      <pubDate>Wed, 12 Jan 2022 00:00:00 +0000</pubDate>
      
      <guid>https://yen0304.github.io/p/springboot%E5%AD%B8%E7%BF%92%E7%AD%86%E8%A8%98-%E5%96%AE%E5%85%83%E6%B8%AC%E8%A9%A64-%E4%BD%BF%E7%94%A8mockito%E4%BE%86%E6%B8%9B%E5%B0%91%E5%96%AE%E5%85%83%E6%B8%AC%E8%A9%A6%E4%B8%AD%E7%9A%84bean%E4%BE%9D%E8%B3%B4/</guid>
      <description>SpringBoot學習筆記-單元測試(4)-Mockito 前言 部分文章內容來自於古老師在hahow的課程，還有古老師的部落格，想要做筆記的原因是因為，邊記變做會比較容易記住，改天忘了也可以用自己的方式去理解。
Mock測試目的與特性 單元測試的特性為下：
1.可以被自動化運行
2.各個單元測試互相獨立，彼此之間不能有依賴關係
3.測試結果穩定，不受外部服務影響
在前面的筆記，如果要測試Service層的話，應該會這樣寫：
@SpringBootTest public class StudentServiceImplMockTest { @Autowired StudentService studentService; @Test public void getById(){ Student student=studentService.getById(3); assertNotNull(student); assertEquals(3,student.getId()); assertEquals(&amp;#34;Judy&amp;#34;,student.getName()); } } 在上面的測試單元裡，StudentService其實用到了StudentDao這個Bean，
並不符合地２點，Bean之前在上面是有依賴關係的，所以Mock測試的
 目的：避免測試某一個單元測試，而去建構整個bean的依賴。 作法：創造一個假的bean，替換掉容器原有的bean。  在程式裡面Mock的意思為「假的」的意思，而非英文單字模仿。
Mockito Mockito是Spring Boot中，進行Mock測試的工具
功能大致上分為：
 模擬方法的返回值 模擬拋出Exception 記錄方法的使用次數、順序  @MockBean @Test public void getById(){ //第二步  Student mockStudent = new Student(); mockStudent.setId(100); mockStudent.setName(&amp;#34;mockname&amp;#34;); //這句話的意思就是，當有人使用studentDao.getById(3)時，固定return mockStudent這個object  Mockito.when(studentDao.getById(3)).thenReturn(mockStudent); Student student=studentService.getById(3); assertNotNull(student); assertEquals(3,student.getId()); assertEquals(&amp;#34;Judy&amp;#34;,student.getName()); } 執行結果：
org.opentest4j.AssertionFailedError: Expected :3 Actual :100 再把</description>
    </item>
    
    <item>
      <title>SQL學習筆記(3)-水平合併(JOIN ON)與垂直合併(UNION)</title>
      <link>https://yen0304.github.io/p/sql%E5%AD%B8%E7%BF%92%E7%AD%86%E8%A8%983-%E6%B0%B4%E5%B9%B3%E5%90%88%E4%BD%B5join-on%E8%88%87%E5%9E%82%E7%9B%B4%E5%90%88%E4%BD%B5union/</link>
      <pubDate>Wed, 12 Jan 2022 00:00:00 +0000</pubDate>
      
      <guid>https://yen0304.github.io/p/sql%E5%AD%B8%E7%BF%92%E7%AD%86%E8%A8%983-%E6%B0%B4%E5%B9%B3%E5%90%88%E4%BD%B5join-on%E8%88%87%E5%9E%82%E7%9B%B4%E5%90%88%E4%BD%B5union/</guid>
      <description>SQL學習筆記(3)-水平合併(JOIN ON)與垂直合併(UNION) 前言 本系列大多部分來自Hahow的課程－SQL的50道練習，學習過程中得到的筆記，文章內容也有部份都是從教材擷取出來，如果有興趣可以去上課看看。
那這章的基本語法其實網路上的網站fooish都講得蠻完善的了，部分文章內容也會引用網站文章內容。
網路上有人說程式會忘記是很正常的，也因為這次JOIN ON的用法很有趣，所以這次的文章比較多是自己做的圖片，或是個人見解，我希望把程式用白話的方式一一來理解，讓自己能真正的理解他。
開發環境 電腦系統：macOS（Big Sur）
資料庫管理工具：DBeaver
使用語言：SQLite
JOIN ON 水平合併 在JOIN功能中，SQLite分為LEFT JOIN ON以及JOIN ON，但其實差別不大，LEFT JOIN ON的意思是希望保留以左側觀測值為主的資料，但一般來說都會指定要顯示的資料來自於哪個資料表， 所以在SQL中就只有LEFT JOIN ON而沒有JOIN ON。
格式 概念圖： 
SELECTleft_table.column_names,right_table.column_namesFROMtable_nameASleft_tableLEFTJOINtable_nameASright_tableONleft_table.join_key=right_table.join_key;實際使用情境舉例 水平合併的作用在於，今天如果有兩個資料表，一個是
以及學生個人資料表table1資料表，其中裡面存放學生的學號number以及姓名name
學生的考試成績table2資料表，其中存放成績score以及學號number
所以我們想要顯示學生的成績以及姓名時，就需要把兩個欄位一起合併再來顯示，
概念大概是這樣：
   number name  number score  number name score     1 A + 1 90 = 1 A 90   2 B + 2 100 = 2 B 100   3 C + 3 80 = 3 C 80    上面的例子來說，我們要合併的關鍵是兩個資料表所擁有一樣定義的值，這個值在資料庫的實體關係圖（ER Diagram, Entity Relationship Diagram）找到，這些值就是來自於元資料的定義，那在上面的例子中就是學生的學號，這時學號我們就會稱為他為結合鍵（Join Key），</description>
    </item>
    
    <item>
      <title>SQL學習筆記(2)-分組(GROUP BY)與聚合函數結果篩選、子查詢</title>
      <link>https://yen0304.github.io/p/sql%E5%AD%B8%E7%BF%92%E7%AD%86%E8%A8%982-%E5%88%86%E7%B5%84group-by%E8%88%87%E8%81%9A%E5%90%88%E5%87%BD%E6%95%B8%E7%B5%90%E6%9E%9C%E7%AF%A9%E9%81%B8%E5%AD%90%E6%9F%A5%E8%A9%A2/</link>
      <pubDate>Tue, 11 Jan 2022 00:00:00 +0000</pubDate>
      
      <guid>https://yen0304.github.io/p/sql%E5%AD%B8%E7%BF%92%E7%AD%86%E8%A8%982-%E5%88%86%E7%B5%84group-by%E8%88%87%E8%81%9A%E5%90%88%E5%87%BD%E6%95%B8%E7%B5%90%E6%9E%9C%E7%AF%A9%E9%81%B8%E5%AD%90%E6%9F%A5%E8%A9%A2/</guid>
      <description>SQL學習筆記(2)-分組與聚合結果篩選、子查詢 前言 本系列大多部分來自Hahow的課程－SQL的50道練習，學習過程中得到的筆記，文章內容也有部份都是從教材擷取出來，如果有興趣可以去上課看看。
那這章的基本語法其實網路上的網站fooish都講得蠻完善的了，部分文章內容也會引用網站文章內容。
但這次的文章比較多是自己做的圖片，或是個人見解，我希望把程式用白話的方式一一來理解，讓自己能真正的理解他。
開發環境 電腦系統：macOS（Big Sur）
資料庫管理工具：DBeaver
使用語言：SQLite
GROUP BY GROUP BY是一個很重要的敘述句，常常搭配聚合函數(aggregate_function)使用，
下面的aggregate_function(column_name) ，代表使用的聚合函數以及要進行計算的column的名字
WHERE條件篩選則是看場合使用，
GROUP BY 後面如果放了多個column，代表將這些結果越分越細，同時他也具有ORDER BY的功能。
SELECTcolumn_name(s),aggregate_function(column_name)FROMtable_nameWHEREcolumn_nameoperatorvalueGROUPBYcolumn_name1,column_name.2;詳細解說如下
 自己做的&amp;gt;&amp;lt; 
因為GROUP BY每一個群組會傳回一個資料列，所以自然而然就按照了預設的順序排出了第一筆資料。
但其實這時候分組已經完成了，再看下一張圖：
 
GROUP BY可以想像成把指定的column合併分組之後，但實際上是有展開功能的，裡面的數據並不會消失，
所以如果我們要計算每個組別的價錢總和，就使用GROUP BY 組別名稱 在使用聚合函數SUM(columm)，把價錢加總起來，如果在GROUP BY 之後加上的是GROUP BY column_name1, column_name.2，就可以假設在 column_name1之後還有column_name.2分組結果可以展開。
聚合函數COUNT() SELECTCOUNT(column_name)FROMtable_name;COUNT(column_name) 函數用來計算符合查詢條件的欄位紀錄總共有幾筆。
這裡其實需要去理解一下，其實COUNT(column_name)返回的是在指定的column中，欄位值不為NULL的數量，
所以換句話說，如果有NULL值的話並不會被算進去，所以一般不會把有NULL的值放進去做計算，但反觀，
如果都不為NULL的話，就被大家拿來當作查看欄位值有幾筆的函數了，畢竟每個都有值的話，白話說就是數有幾筆數量，但如果在資料表觀測值都不為NULL的情況下，大家的筆數都會一樣，所以這時候就會變成我們常用的
COUNT()或是COUNT(*)，意思都一樣。
當COUNT遇上GROUP BY 這是個超常會碰到的用法，在資料皆不為null的情況下，
COUNT的意思是「有幾筆資料」 ，
GROUP的意思則是「分組」
合起來用變成，「分組的組別有幾筆資料」。
範例  moives資料表（部分） 
在50道練習當中，某一道題目如下
從 imdb 資料庫的 movies 資料表計算每一年有幾部在 IMDb.com
獲得高評等的經典電影，參考下列的預期查詢結果。
從上面我們可以知道要如何解題
 首先寫上 SELECT FROM movies，先選好要顯示資料在哪一個資料表 接著要計算「每一年」，所以我們把年進行分組GROUP BY release_year 再來使用COUNT(*)計算每一組的比數，意思就是在GROUP BY release_year以年分組後展開後有幾筆數量，也因為大家都不為NULL，所以這個數字也變成了有幾部電影的數量 選擇其他要顯示SELECT release_year,COUNT(*) AS number_of_movies  合起來變成：</description>
    </item>
    
    <item>
      <title>SQL學習筆記(1)-資料查詢、獨顯一值、運算符、函數</title>
      <link>https://yen0304.github.io/p/sql%E5%AD%B8%E7%BF%92%E7%AD%86%E8%A8%981-%E8%B3%87%E6%96%99%E6%9F%A5%E8%A9%A2%E7%8D%A8%E9%A1%AF%E4%B8%80%E5%80%BC%E9%81%8B%E7%AE%97%E7%AC%A6%E5%87%BD%E6%95%B8/</link>
      <pubDate>Mon, 10 Jan 2022 00:00:00 +0000</pubDate>
      
      <guid>https://yen0304.github.io/p/sql%E5%AD%B8%E7%BF%92%E7%AD%86%E8%A8%981-%E8%B3%87%E6%96%99%E6%9F%A5%E8%A9%A2%E7%8D%A8%E9%A1%AF%E4%B8%80%E5%80%BC%E9%81%8B%E7%AE%97%E7%AC%A6%E5%87%BD%E6%95%B8/</guid>
      <description>SQL學習筆記(1)-資料查詢、獨顯一值、運算符、函數 前言 本系列大多部分來自Hahow的課程－SQL的50道練習，學習過程中得到的筆記，文章內容也有部份都是從教材擷取出來，如果有興趣可以去上課看看！
那這張的基本語法其實網路上的網站fooish都講得蠻完善的了，部分文章內容也會引用網站文章內容。
開發環境 電腦系統：macOS（Big Sur）
資料庫管理工具：DBeaver
使用語言：SQLite
MySQL &amp;amp; SQLite差異 在語法中大多相同，所以SQLite對我的學習上是有幫助的，這兩者最大的差異主要是SQLite不支持網路訪問， 沒有伺服器的特性，但他也跟他的名字一樣，在設定、管理上都更加的輕盈、快速，有興趣可以到這個網路文章參考看看。
SELECT、FROM SELECT 敘述句主要由兩部分構成，第一部分是要 &amp;ldquo;拿什麼&amp;rdquo; 資料 (若有多項用逗號隔開)；第二部分則為 &amp;ldquo;從哪拿&amp;rdquo;。
SELECTtable_column1,table_column2,table_column3...FROMtable_name;這個應該不會有什麼問題！
這裡table_column1, table_column2指的是要從資料表拿取col的名稱，table_name則是從哪一個資料表拿取。
LIMIT 主要用來限制資料查詢的數量（number）
SELECTtable_column1,table_column2...FROMtable_nameLIMITnumber;範例 在課程中，imdb.db的有一個名字叫movies的資料表（table）；
如果想觀看資料表的全部可以搭配「＊」，「＊」意思是全選
SELECT ＊ FROM movies 結果；
   id title release_year rating director runtime     1 The Shawshank Redemption 1994 9.3 Frank Darabont 142   2 The Godfather 1972 9.2 Francis Ford Coppola 175   3 The Godfather: Part II 1974 9.</description>
    </item>
    
    <item>
      <title>SpringBoot電商平台實戰(2)，商品詳情、熱門商品排序</title>
      <link>https://yen0304.github.io/p/springboot%E9%9B%BB%E5%95%86%E5%B9%B3%E5%8F%B0%E5%AF%A6%E6%88%B02%E5%95%86%E5%93%81%E8%A9%B3%E6%83%85%E7%86%B1%E9%96%80%E5%95%86%E5%93%81%E6%8E%92%E5%BA%8F/</link>
      <pubDate>Sun, 09 Jan 2022 00:00:00 +0000</pubDate>
      
      <guid>https://yen0304.github.io/p/springboot%E9%9B%BB%E5%95%86%E5%B9%B3%E5%8F%B0%E5%AF%A6%E6%88%B02%E5%95%86%E5%93%81%E8%A9%B3%E6%83%85%E7%86%B1%E9%96%80%E5%95%86%E5%93%81%E6%8E%92%E5%BA%8F/</guid>
      <description>SpringBoot電商平台實戰(2) 前言 本章承SpringBoot電商平台實戰(1)的專案，所以配置、工具等等都一樣。
在實作商品有關的MVC時，其實沒有遇到什麼困難，畢竟東西熟悉了，也不用去用到session或是驗證等等，時間花最久的應該是在前端的javascript吧！因為本身沒有在做太多的研究，所以就依照兩年前學的也把它做完了，那些東西看了程式碼應該都知道，所以有興趣的可以至github下載，這章節就不做太多的介紹了。
免跨域註解@CrossOrigin的另一個方法 之後看到網路上的連接，得知不用加上@CrossOrigin(origins = &amp;ldquo;*&amp;quot;)
可以參考本連結，也是透過設置webconfiguration的方式
程式碼：
@Configuration public class CORSConfig { @Bean public WebMvcConfigurer corsConfigurer() { return new WebMvcConfigurerAdapter() { @Override public void addCorsMappings(CorsRegistry registry) { registry.addMapping(&amp;#34;/**&amp;#34;) .allowedHeaders(&amp;#34;*&amp;#34;) .allowedMethods(&amp;#34;*&amp;#34;) .allowedOrigins(&amp;#34;*&amp;#34;); } }; } } 所以maven中也可以省去了
&amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;commons-codec&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;commons-codec&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;1.11&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; 規劃資料庫中的商品數據 資料表創建相關數據：
CREATETABLEt_product(idINTAUTO_INCREMENTPRIMARYKEY,categoryIdINT(20)DEFAULTNULLCOMMENT&amp;#39;商品分類id&amp;#39;,typeCHAR(100)DEFAULTNULLCOMMENT&amp;#39;商品類別&amp;#39;,titleCHAR(60)DEFAULTNULLCOMMENT&amp;#39;商品標題（名稱）&amp;#39;,priceINT(20)COMMENT&amp;#39;單價&amp;#39;,numINT(20)COMMENT&amp;#39;數量&amp;#39;,imagepathVARCHAR(100)COMMENT&amp;#39;圖片路徑&amp;#39;,priorityINT(10)DEFAULTNULLCOMMENT&amp;#39;顯示優先程度&amp;#39;,statusINT(1)DEFAULT1COMMENT&amp;#39;上架狀態1是0否&amp;#39;,created_userVARCHAR(20)COMMENT&amp;#39;創建人&amp;#39;,created_timeDATETIMECOMMENT&amp;#39;創建時間&amp;#39;,modified_userVARCHAR(20)COMMENT&amp;#39;最後修改人&amp;#39;,modified_timeDATETIMECOMMENT&amp;#39;最后修改時間&amp;#39;)Product Class 接下來創建Product這個類別，當然繼承了BaseEntity
@Data public class Product extends BaseEntity implements Serializable { private Integer id; private Integer categoryId; private String type; private String title; private Integer price; private Integer num; private String imagepath; private Integer status; private Integer priority; } ProductRowMapper public class ProductRowMapper implements RowMapper&amp;lt;Product&amp;gt; { @Override public Product mapRow(ResultSet resultSet, int i) throws SQLException { Product product=new Product(); //後面result.</description>
    </item>
    
    <item>
      <title>SpringBoot電商平台實戰(1)，用戶註冊、用戶登入、修改資料</title>
      <link>https://yen0304.github.io/p/springboot%E9%9B%BB%E5%95%86%E5%B9%B3%E5%8F%B0%E5%AF%A6%E6%88%B01%E7%94%A8%E6%88%B6%E8%A8%BB%E5%86%8A%E7%94%A8%E6%88%B6%E7%99%BB%E5%85%A5%E4%BF%AE%E6%94%B9%E8%B3%87%E6%96%99/</link>
      <pubDate>Sat, 08 Jan 2022 00:00:00 +0000</pubDate>
      
      <guid>https://yen0304.github.io/p/springboot%E9%9B%BB%E5%95%86%E5%B9%B3%E5%8F%B0%E5%AF%A6%E6%88%B01%E7%94%A8%E6%88%B6%E8%A8%BB%E5%86%8A%E7%94%A8%E6%88%B6%E7%99%BB%E5%85%A5%E4%BF%AE%E6%94%B9%E8%B3%87%E6%96%99/</guid>
      <description>SpringBoot電商平台實戰(1) 前言 在練習的差不多之後，決定實作一個完整的電商平台「SpringBoot電商平台實戰」，也參考了不少網路上的資源，主要是參考CSDN上的雨醉東風（由於不知能不能引用所以有興趣可以自行查詢）來撰寫api，參考架構，差別最大的是該教學是使用MyBatis做資料庫操作，而我是使用JDBC，預計將來會再嘗試Redis、SpringSecurity、再加上前端完成一個完整的網站。
本來在2021年的10月初已經做好了，但遇到需要實作記住持續登入的功能，雖然SpringSecurity做得到，但部分功能都涉及到session，還有登入時候的POST方法驗證登入，變成了SpringSecurity + 自己做的POST一起登入的問題，還有持續保持登入狀態等問題，將來會再更熟悉SpringSecurity再把他做整合。
本例相關工具、環境、語言、配置 開發環境：
 Java 11 IntelliJ IDEA 2020.3.2 Spring Boot 2.3.7 RELEASE  工具：
Lombok（使用教學）用途：提高開發效率，自動產生getter以及setter等等。
資料庫：MySql 8.0.22
操作資料庫方法：JDBC
前端模板引擎：Freemarker
其他：
前端：html、css、javascript、jquery、ajax
學習到的新知識：
密碼加密、統一異常處例、AOP、MVC、Spring Session
如果以上有東西不熟悉的話，可以參考本網站個文章來做參考。
application.properties配置 #DB Configuration spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver spring.datasource.url=jdbc:mysql://localhost:3306/db_store?serverTimezone=Asia/Taipei&amp;amp;characterEncoding=utf-8 spring.datasource.username=root spring.datasource.password=springboot #Spring Session ## Session 存儲方式 spring.session.store-type=redis ## Session 過期時間，默認單位為 s server.servlet.session.timeout=600 ## Session 存儲到 Redis 鍵的前綴 spring.session.redis.namespace=test:spring:session #Freemaker設定 spring.freemarker.cache=false # 模版後綴名 默認為ftl spring.freemarker.suffix=.ftl # 文件編碼 spring.freemarker.charset=UTF-8 # 模版加載的目錄 spring.freemarker.template-loader-path=classpath:/templates/ # 靜態資源訪問路徑 spring.mvc.static-path-pattern=/static/** # 獲取根目錄路徑 spring.</description>
    </item>
    
    <item>
      <title>Freemarker &#43; Spring Security 整合</title>
      <link>https://yen0304.github.io/p/freemarker-spring-security-%E6%95%B4%E5%90%88/</link>
      <pubDate>Thu, 23 Dec 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yen0304.github.io/p/freemarker-spring-security-%E6%95%B4%E5%90%88/</guid>
      <description>Freemarker + Spring Security 整合 由於方便往後的實戰學習，在學會了快速的在Spring Boot 使用Freemarker在localhost:8080上執行之後，也學會了用Spring Security 控制訪問權限，在整合他們途中，其實遇到了不少配置上的問題，但也成功解決了，所以決定記錄這些解決問題的過程，也更了解了Spring Security的認證寫法。
pom.xml maven配置 Spring Security （先不要加上spring Security，因為加上去了所有為配置的默認都會受到全縣控管）
&amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-boot-starter-security&amp;lt;/artifactId&amp;gt; &amp;lt;/dependency&amp;gt; Freemarker &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-boot-starter-freemarker&amp;lt;/artifactId&amp;gt; &amp;lt;/dependency&amp;gt; Application.properties配置 Freemaker設定 #Freemaker設定spring.freemarker.cache=false# 模版後綴名 默認為ftlspring.freemarker.suffix=.ftl# 文件編碼spring.freemarker.charset=UTF-8# 模版加載的目錄spring.freemarker.template-loader-path=classpath:/templates/# 靜態資源訪問路徑spring.mvc.static-path-pattern=/static/**# 獲取根目錄路徑spring.freemarker.request-context-attribute=request開始撰寫程式部分 這部分的先後順序很重要，因為如果Freemarker其中有錯誤，css或js會跑不出來，也同樣的Spring Security如果有錯誤，css或js也會因爲訪問權限而跑不出來，所以在撰寫時順序如下
撰寫順序  確認Freemarker配置成功，包含get請求，以及靜態資源css js訪問成功 使用Spring Security下，得知靜態支援有受到保護，並請把保護關閉。 使用Spring security測試相關功能。  Freemaker靜態配置至測試成功 檔案存放位置 檔案存放位置很重要，也跟application.properties很相關，包含了靜態資源的訪問路徑，
這次規劃了user_login.ftl、login.css、login.js為登入Spring Security角色頁面
，login_success、login_success.css為登入成功登入之後跳轉的頁面
 ftl、css、js檔案存放配置 
Ftl(html)存取css、js之重點 在login_success下，存取css、js的html語法為下
&amp;lt;link rel=&amp;#34;stylesheet&amp;#34; href=&amp;#34;/static/css/login.css&amp;#34;&amp;gt; &amp;lt;script src=&amp;#34;/static/js/login.js&amp;#34;&amp;gt;&amp;lt;/script&amp;gt; 重點就是因為我們已經配置好了路徑，所以會因Freemarker會有不同的寫法
Controller層 應該沒什麼好解釋的
@Controller public class Controller { @GetMapping(&amp;#34;/user_login&amp;#34;) public String loginpage(Model model) { return &amp;#34;/user_login&amp;#34;; } @GetMapping(&amp;#34;/login_success&amp;#34;) public String successpage(Model model) { return &amp;#34;/login_success&amp;#34;; } } 如何判斷測試成功 運行SpringBoot之後，以下圖解是我們看到的畫面，使用瀏覽器是chrome</description>
    </item>
    
    <item>
      <title>SpringBoot學習筆記-單元測試(3)-Controller層、Dao層、Service層的測試方式，MockMvc使用詳解 </title>
      <link>https://yen0304.github.io/p/springboot%E5%AD%B8%E7%BF%92%E7%AD%86%E8%A8%98-%E5%96%AE%E5%85%83%E6%B8%AC%E8%A9%A63-controller%E5%B1%A4dao%E5%B1%A4service%E5%B1%A4%E7%9A%84%E6%B8%AC%E8%A9%A6%E6%96%B9%E5%BC%8Fmockmvc%E4%BD%BF%E7%94%A8%E8%A9%B3%E8%A7%A3/</link>
      <pubDate>Wed, 22 Dec 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yen0304.github.io/p/springboot%E5%AD%B8%E7%BF%92%E7%AD%86%E8%A8%98-%E5%96%AE%E5%85%83%E6%B8%AC%E8%A9%A63-controller%E5%B1%A4dao%E5%B1%A4service%E5%B1%A4%E7%9A%84%E6%B8%AC%E8%A9%A6%E6%96%B9%E5%BC%8Fmockmvc%E4%BD%BF%E7%94%A8%E8%A9%B3%E8%A7%A3/</guid>
      <description>SpringBoot學習筆記-單元測試(3)-Controller層、Dao層、Service層的測試方式，MockMvc使用詳解 Dao層以及Service層的測試方式 使用JUnit5測試SpringBoot程式 @SpringBootTest註解  只要在測試用的class上面加上@SpringBootTest，就會在單元測試時啟動Spring容器，也會創建Bean出來 這個@SpringBootTest的註解的功能非常完善，除了創建Bean之外，@Configuration或是攔截器Interceptor都會被生效，也就是等同於運行SpringBoot程式。 通常會把測試用的class變成public，  做好了準備之後可以運行看看成效以及顯示的結果為何：
@SpringBootTest public class StudentDaoImplTest { //注入bean  @Autowired private StudentDao studentDao; @Test public void getById(){ Student student = studentDao.getById(1); assertNotNull(student); assertEquals(&amp;#34;Amy&amp;#34;,student.getName()); } } 運行成果：
 
@Transactional註解 假設今天我們透過@Test想測試deleteById的方法時，實際上是會去真實刪除資料庫裡面的數據的，所以如果先執行了測試deleteById，在執行測試getById，這時候如果Id是一樣的情況下，就會影響到測試結果，雖然可以透過測試不同的Id來避免此情況，但在越複雜的專案時此方法很不適合，所以我們可以透過加上@Transactional註解，在單元測試結束之後，SpringBoot會去rollback（回滾）這個單元測試裡面所有的資料庫操作。
使用範例：
@Transactional @Test public void deleteById(){ studentDao.deleteById(1); Student student =studentDao.getById(1); assertNull(student); } 不同的@Transactional註解 @Transactional在不同的資料夾下，有不同的差異，
   資料夾 @Transactional公用     main資料夾 程式運行中發生錯誤才進行rollback   test資料夾 單元測試結束之後，強制執行rollback    Controller層的測試 Controller層的測試目的在於，要模擬前端呼叫真實API CAll的行為，看API是否能運行正確，並且不能透過注入Bean的方式來測試，意思就是模擬http request</description>
    </item>
    
    <item>
      <title>SpringBoot學習筆記-單元測試(2)-JUnit5使用教學</title>
      <link>https://yen0304.github.io/p/springboot%E5%AD%B8%E7%BF%92%E7%AD%86%E8%A8%98-%E5%96%AE%E5%85%83%E6%B8%AC%E8%A9%A62-junit5%E4%BD%BF%E7%94%A8%E6%95%99%E5%AD%B8/</link>
      <pubDate>Mon, 20 Dec 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yen0304.github.io/p/springboot%E5%AD%B8%E7%BF%92%E7%AD%86%E8%A8%98-%E5%96%AE%E5%85%83%E6%B8%AC%E8%A9%A62-junit5%E4%BD%BF%E7%94%A8%E6%95%99%E5%AD%B8/</guid>
      <description>SpringBoot學習筆記-單元測試(2)-JUnit JUnit介紹 何謂JUnit?  jUnit是java單元測試的必備工具 只要在方法上加入@Test，即可生成一個單元測試  JUnit與Spring Boot的關係   Spring Boot &amp;lt;=2.1
只能使用JUnit4
  Spring Boot 2.2 2.3
可以使用JUnit4、JUint5。
  Spring boot &amp;gt;=2.4
只能使用JUnit5
  所以綜合上述，現階段會以Junit5作為主流，其中需要注意的是，Spring Boot如果在2.2以及2.3版本中，需要到pom.xml加上額外設定才能禁用JUint4。
在Spring Boot 2.2版本或2.3版本禁用JUnit4 如果需要在Spring Boot 2.2版本或2.3版本禁用JUnit4在pom.xml中，我們的程式碼其中有關測試單元的大致上會長這樣：
&amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-boot-starter-test&amp;lt;/artifactId&amp;gt; &amp;lt;scope&amp;gt;test&amp;lt;/scope&amp;gt; &amp;lt;/dependency&amp;gt; 我們只需新增下面這幾段程式碼即可禁用JUnit4，上面那段程式碼會變成這樣：
&amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-boot-starter-test&amp;lt;/artifactId&amp;gt; &amp;lt;scope&amp;gt;test&amp;lt;/scope&amp;gt; &amp;lt;exclusions&amp;gt; &amp;lt;exclusion&amp;gt; &amp;lt;groupId&amp;gt;org.junit.vintage&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;junit-vintage-engine&amp;lt;/artifactId&amp;gt; &amp;lt;/exclusion&amp;gt; &amp;lt;/exclusions&amp;gt; &amp;lt;/dependency&amp;gt; Junt5的用法 Junit5的用法 以圖片說明：
 
其中第三點看起來簡單，但正是最精華的所在處，因為如果要讓團隊或是別人看懂這個方法的作用，命名正是我們最重要的工作。
JUnit5 Assert 下面用表格來說明Assert斷言用法的主要用途
   Assert系列用法 用途     assertNull(A) 斷言A為Null   assertNotNull(A) 斷言A不為Null   assertEquals(A,B) 斷言A與B相等   assertTure(A) 斷言A為True   assertFalse(A) 斷言A為False   assertThrows(exception,method) 斷言執行method的時候，會噴出exception    JUnit其他常用註解 @BeforceEach @BeforceEach：在每次@Test開始之前，「都會」執行一次</description>
    </item>
    
    <item>
      <title>SpringBoot學習筆記-單元測試(1)-基礎介紹</title>
      <link>https://yen0304.github.io/p/springboot%E5%AD%B8%E7%BF%92%E7%AD%86%E8%A8%98-%E5%96%AE%E5%85%83%E6%B8%AC%E8%A9%A61-%E5%9F%BA%E7%A4%8E%E4%BB%8B%E7%B4%B9/</link>
      <pubDate>Sun, 19 Dec 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yen0304.github.io/p/springboot%E5%AD%B8%E7%BF%92%E7%AD%86%E8%A8%98-%E5%96%AE%E5%85%83%E6%B8%AC%E8%A9%A61-%E5%9F%BA%E7%A4%8E%E4%BB%8B%E7%B4%B9/</guid>
      <description>SpringBoot學習筆記-單元測試(1) 在學了SpringBoot中，不少的核心知識CRUD操作，接下來要學習的是該如何去測試我們撰寫好的功能
何謂單元測試（Unit Testing）？ 目的：自動化測試程式的正確性
所謂的單元測試，就是一次只測試一個功能點，一個單元可以是一個method，或是一個API
單元測試的特性＆注意事項 單元測試的特性 1.可以被自動化運行
2.各個單元測試互相獨立，彼此之間不能有依賴關係
3.測試結果穩定，不受外部服務影響
單元測試的注意事項 1.測試的程式要放在test資料夾裡面
2.測試的class名稱以「原class的名字加上Test做為結尾」來命名
3.測試的class的package要跟原class的package保持一致
環境部署&amp;amp;基礎範例  環境部署 如果想要在springboot裡面使用單元測試功能，要在pom.xml裏面新增這個maven，不過這段程式碼在一般創建springboot程式中就會加上去了
&amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-boot-starter-test&amp;lt;/artifactId&amp;gt; &amp;lt;scope&amp;gt;test&amp;lt;/scope&amp;gt; &amp;lt;/dependency&amp;gt;  開始測試 先在demo的package底下新增一個簡易的計算機class Calcultor ，
首先如果我們一般在進行撰寫時，程式大概會長這樣：
public class Calcultor { public int add(int x,int y){ return(x+y); } public static void main(String[] args) { Calcultor calcultor =new Calcultor(); int result = calcultor.add(1,2); System.out.println(&amp;#34;結果為&amp;#34; + result); } } 結果會理所當然的出現結果為3，但假設今天某個工程師在add方法裡寫錯了，就必須花時間去尋找add方法裡是否有錯誤，所以我們這時候就要去利用單元測試去完成自動化測試。
首先在Calcultor 裡面點擊右鍵，選擇Generate-&amp;gt;Test ，Testing Library選擇JUnit5 如下圖：
 
接著就可以看到在Test底下的demo Package看到CalculatorTest這個Class，我們用以下程式碼來完成第一個測試的程式：</description>
    </item>
    
    <item>
      <title>Spring Security(4)訪問權限註解@Securitd、@PreAuthorize</title>
      <link>https://yen0304.github.io/p/spring-security4%E8%A8%AA%E5%95%8F%E6%AC%8A%E9%99%90%E8%A8%BB%E8%A7%A3securitdpreauthorize/</link>
      <pubDate>Sat, 18 Sep 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yen0304.github.io/p/spring-security4%E8%A8%AA%E5%95%8F%E6%AC%8A%E9%99%90%E8%A8%BB%E8%A7%A3securitdpreauthorize/</guid>
      <description>前置作業 前置作業方面，需要先在資料庫中新增使用者數據，並完成使用JDBC進行登入帳密的功能，可以參考
Spring Security(2)使用Spring Security自定義使用者帳密、使用JDBC串接資料庫，然後先新增一筆使用者帳密，並權限設定為ROLE_USER
@EnableGlobalMethodSecurity @EnableGlobalMethodSecurity這個註解是表示，我們要透過@Securitd， @PreAuthorize，@RolesAllowed這些註解，並透過用戶權限來訪問我們的方法
第一種使用方式：
@EnableGlobalMethodSecurity的用法就是加在配置類中就可以了，當然我們熟悉的@configuration是用來表示此類別是用來設定springboot用的，@EnableGlobalMethodSecurity已經包含了@configuration，所以我們直接在我們繼承WebSecurityConfigurerAdapter的類別上面加上@EnableGlobalMethodSecurity註解即可
@EnableGlobalMethodSecurity public class SecurityConfig extends WebSecurityConfigurerAdapter { //... } 第二種是用方式：
放在啟動類上面(Application)。
@EnableGlobalMethodSecurity @SpringBootApplication public class DemoApplication { public static void main(String[] args) { SpringApplication.run(DemoApplication.class, args); } } 而如果要使用@Secured、@PreAuthorize、@PostAuthorize，的話都要先開啟註解功能，也就是在我們的@EnableGlobalMethodSecurity加上(Securitd=true)、(prePostEnabled = true)、
舉例：
開啟@Secured功能
@EnableGlobalMethodSecurity(securedEnabled=true)
開啟@PreAuthorize或是@PostAuthorize
@EnableGlobalMethodSecurity(securedEnabled = true,prePostEnabled = true) 如果要同時使用的話，@EnableGlobalMethodSecurity(securedEnabled = true,prePostEnabled = true)，就可以了
四種加在方法上的註解 主要是@Securitd、@PreAuthorize最為常用，
所以下面實作中會解釋兩者最大的差別
   Security Annotation (註解) 使用時機     @Secured 用戶有某個角色，驗證後進行方法   @PreAuthorize 在方法執行之前進行驗證，並能將用戶的roles/premission參數傳入到方法中   @PostAuthorize 在方法執行之後，在進行驗證   @PostFilter 將方法的返回數值進行過濾   @PreFilter 將傳入方法的值進行過濾    實作 以下實作最常使用到的@Secured以及@PreAuthorize，可以發現@PreAuthorize在設定權限參數中，使用了hasAnyAuthority加入前綴，使權限在資料庫的名稱為ROLE_USER，hasAnyAuthority是spring EL表示式（Spring Expression Language）的一種，@Secured並沒有支援spring EL表示式，且也沒有像@PreAuthorize可以將驗證的參數傳入方法中，所以簡單來說@PreAuthorize就是@Secured的加強版</description>
    </item>
    
    <item>
      <title>Spring Security(3)自定義登入頁面、控制角色權限登入</title>
      <link>https://yen0304.github.io/p/spring-security3%E8%87%AA%E5%AE%9A%E7%BE%A9%E7%99%BB%E5%85%A5%E9%A0%81%E9%9D%A2%E6%8E%A7%E5%88%B6%E8%A7%92%E8%89%B2%E6%AC%8A%E9%99%90%E7%99%BB%E5%85%A5/</link>
      <pubDate>Sun, 12 Sep 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yen0304.github.io/p/spring-security3%E8%87%AA%E5%AE%9A%E7%BE%A9%E7%99%BB%E5%85%A5%E9%A0%81%E9%9D%A2%E6%8E%A7%E5%88%B6%E8%A7%92%E8%89%B2%E6%AC%8A%E9%99%90%E7%99%BB%E5%85%A5/</guid>
      <description>前言 在前一章Spring Security(2)使用Spring Security自定義使用者帳密、使用JDBC串接資料庫中，我們知道了如何透過Spring Security自定義的角色來訪問我們的頁面，接下來要做的是，如何設定哪些頁面不用登入跟可以訪問、哪些頁面有帳號密碼到才可以訪問，或是我們自定義的權限角色管理員、銷售員、就像賣場的賣家與用戶一樣，去控制這些頁面，也將訪問頁面設定成前端設計好的頁面，實現真正的前後端分離，減少溝通成本。
自定義登入頁面 要自定義頁面時，一樣到專門設定Spring Security中的一個類別WebSecurityConfigurerAdapter，在前幾章中我們用了SecurityConfig去繼承他，在自定義頁面時，我們要先實作方法configure(HttpSecurity http)，一樣按右鍵-&amp;gt;Generate-&amp;gt;Override Methods，選擇configure(HttpSecurity http)。
在使用之前，值得注意的事情是SecurityConfig的antMatchers順序是有關係的，在每一個url執行時，程式如果返回了True下面就不會執行了，例如，如果anyRequest().permitAll()設定在其他規則比較嚴格條件的前面的話，Spring Security判斷符合條件，就不會往下在走，意思是最鬆的規則應該在放在最後面，越是嚴格的規則要放在前面。
下面範例提供了幾個較常用的功能，如下：
@Override protected void configure(HttpSecurity http) throws Exception { http.formLogin() //自定義登入頁面  .loginPage(&amp;#34;/login.html&amp;#34;) .loginProcessingUrl(&amp;#34;/user/login&amp;#34;) //設定登入頁面的url  .usernameParameter(&amp;#34;uname&amp;#34;)///登入表單form中使用者名稱輸入框input的name名，不修改的話預設是username  .passwordParameter(&amp;#34;pword&amp;#34;)//form中密碼輸入框input的name名，不修改的話預設是password  .defaultSuccessUrl(&amp;#34;/home&amp;#34;) //成功登入之後導向  .and().authorizeRequests() //表示要定義哪些被保護(.authenticated())，哪些不需要保護（authorizeRequests()）  .antMatchers(&amp;#34;/&amp;#34;,&amp;#34;/hello&amp;#34;).permitAll() //設置不管有無登入都可以直接訪問(permitAll)  .anyRequest().authenticated() //這樣寫代表除了以上之外，其他都需要被保護  .and().csrf().disable(); //關閉csrf防護 } 選擇角色權限進行控制的四種方法 在Spring Security中，我們可以針對用戶的角色進行訪問頁面的權限控制，例如說，設定某些頁面管理員才能訪問，有些頁面大家都可以訪問，或是自定義的角色等等，針對各種不同的情況，共有四種方法，返回都是True or False
四種方法比較表格    方法名稱 舉例 意思     hasAuthority(String authority) hasAuthority(&amp;ldquo;ADMIN&amp;rdquo;) ADMIN角色才可以訪問   hasAnyAuthority(String&amp;hellip; authorities) hasAnyAuthority(&amp;ldquo;ADMIN,MANAGER&amp;rdquo;) 有ADMIN或MANAGER其中一個符合就可以訪問   hasRole(String role) hasRole(&amp;ldquo;Sale&amp;rdquo;) 角色權限全名ROLE_Sale才可以訪問   hasAnyRole(String&amp;hellip; roles) hasAnyRole(&amp;ldquo;Sale,User&amp;rdquo;) 有角色權限全名ROLE_Sale或ROLE_User其中一者就可以訪問    hasAuthority()跟 hasRole()的雖然很像，其實都是設定角色是否可以訪問，但是如果查看一下hasRole()的來源碼，就可以知道差別</description>
    </item>
    
    <item>
      <title>Spring Security(2)使用Spring Security自定義使用者帳密、使用JDBC串接資料庫</title>
      <link>https://yen0304.github.io/p/spring-security2%E4%BD%BF%E7%94%A8spring-security%E8%87%AA%E5%AE%9A%E7%BE%A9%E4%BD%BF%E7%94%A8%E8%80%85%E5%B8%B3%E5%AF%86%E4%BD%BF%E7%94%A8jdbc%E4%B8%B2%E6%8E%A5%E8%B3%87%E6%96%99%E5%BA%AB/</link>
      <pubDate>Sat, 04 Sep 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yen0304.github.io/p/spring-security2%E4%BD%BF%E7%94%A8spring-security%E8%87%AA%E5%AE%9A%E7%BE%A9%E4%BD%BF%E7%94%A8%E8%80%85%E5%B8%B3%E5%AF%86%E4%BD%BF%E7%94%A8jdbc%E4%B8%B2%E6%8E%A5%E8%B3%87%E6%96%99%E5%BA%AB/</guid>
      <description>繼上一章了解到了Spring Security基本的作用之後，本章節來繼續深入瞭解有關Spring Security中權限還有認證的相關設置，以及如何串接MySql資料庫數據來進行用戶認證 大概會用到的核心功能有JDBC Authentication、WebSecurityConfigurerAdapter、UserDetailsService
自訂用戶、查詢資料庫中帳號密碼 在Spring Security中，自訂登入系統的帳號與密碼主要有二種方法兩種，第一種就是透過程式設定來在後臺上寫上固定的自定義帳號密碼，第二種則是
添加依賴 &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-boot-starter-security&amp;lt;/artifactId&amp;gt; &amp;lt;/dependency&amp;gt; 配置application.properties 語法如下，也是最簡單的方式，在resource下找到application.properties並輸入：
spring.security.user.name=testad #自定義帳號 spring.security.user.password=abc123 #自定義密碼 透過繼承類別WebSecurityConfigurerAdapter 先新增一個類別SecurityConfig來繼承WebSecurityConfigurerAdapter，WebSecurityConfigurerAdapter是專門用來配置Spring Security的一個類別：
@Configuration //小複習:當@Configuration加在class上，表示這是一個設定spring用的class（裡面寫的東西都是設定spring) public class SecurityConfig extends WebSecurityConfigurerAdapter { //... } 再來使用configure方法來設置我們的用戶設定，在IDEA中點擊右鍵-&amp;gt;Generate-&amp;gt;Override Methods選擇我們要覆寫的方法configure(AuthenticationManagerBuilder auth)（真是方便）
會出現：
@Override protected void configure(AuthenticationManagerBuilder auth) throws Exception { super.configure(auth); } 在這個方法中，主要透過auth來設置我們的用戶名以及密碼，但在下面得例子中，也使用了Spring Security提供了類別的BCryptPasswordEncoder來加密我們的密碼，在使用BCryptPasswordEncoder時，因為我們改變了password()的接受參數類型，所以也要記得使用@Bean來實作一個password類型
@Bean PasswordEncoder password(){ return new BCryptPasswordEncoder(); } 再來就是Spring Security在進行安全驗證時，會收到輸入請求中的使用者名稱(username)，然後呼叫UserDetailsService，UserDetailsService是Spring Security用來載入使用者資訊的一個組件，他的功能就是可以提供UserDetailsService中的一個方法loadUserByUsername(String username)，來依據username回傳資料型別UserDetails的使用者資訊（參考文章：Spring Security UserDetailsService 用途)
所以我們先
實作UserDetailsService 在implements UserDetailsService的時候，只需要實作一個方法就好，那就是loadUserByUsername，在學習這裡時，稍微了解到了@Service以及＠Component的差別，就是除了閱讀讓人知道Service是處理業務邏輯之外，實際上功能其實都是一樣讓class變成Bean。
//MyUsersDetailService完整程式碼：  @Service public class MyUsersDetailService implements UserDetailsService { @Override public UserDetails loadUserByUsername(String s) throws UsernameNotFoundException { //權限(固定用法,role是還沒用到所以拿來暫時先隨便亂取）  List&amp;lt;GrantedAuthority&amp;gt; auths = AuthorityUtils.</description>
    </item>
    
    <item>
      <title>Spring Security(1)認識Spring Security＆微演練</title>
      <link>https://yen0304.github.io/p/spring-security1%E8%AA%8D%E8%AD%98spring-security%E5%BE%AE%E6%BC%94%E7%B7%B4/</link>
      <pubDate>Thu, 02 Sep 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yen0304.github.io/p/spring-security1%E8%AA%8D%E8%AD%98spring-security%E5%BE%AE%E6%BC%94%E7%B7%B4/</guid>
      <description>什麼是Spring Security ？ Spring Security 是一個安全框架，
在安全方面有兩個核心機制：驗證（authentication），大致上就是指系統去認證使用者是否能登入，授權（authorization）就是給予用戶權限去做某些特定的操作。
簡單實作了解實際功用 下面示範Spring Security的實際作用，只需幾個步驟就可以解決！
Maven設定 &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-boot-starter-security&amp;lt;/artifactId&amp;gt; &amp;lt;/dependency&amp;gt; 設計Controller @RestController public class TestController { @RequestMapping(&amp;#34;/test123&amp;#34;) public String test() { return &amp;#34;安安123&amp;#34;; } 實際運行結果 這樣就可以執行了，但是一般來說，我們輸入localhost:8080/test123時，應該會出現方法的回傳訊息&amp;quot;安安123&amp;quot;，但當我們將網頁導向localhost:8080/test會出現下面這張照片：
 要求登入畫面 
在Spring Security中，預設的帳號是user，密碼則是可以從後台的console看到
 密碼地方 
所以帳號輸入：user 密碼則輸入程式運行時給的密碼，就能成功看到畫面：
 
在這嘗試玩之後個人有使用APItester做get測試，結果會回傳401錯誤，如下圖：
 
到這邊就差不多了解到了Spring Security 的作用之處了，期待日後的學習能更順利～！。</description>
    </item>
    
    <item>
      <title>Spring Boot 管理會員資料（二）-CRUD之RUD操作</title>
      <link>https://yen0304.github.io/p/spring-boot-%E7%AE%A1%E7%90%86%E6%9C%83%E5%93%A1%E8%B3%87%E6%96%99%E4%BA%8C-crud%E4%B9%8Brud%E6%93%8D%E4%BD%9C/</link>
      <pubDate>Sat, 28 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yen0304.github.io/p/spring-boot-%E7%AE%A1%E7%90%86%E6%9C%83%E5%93%A1%E8%B3%87%E6%96%99%E4%BA%8C-crud%E4%B9%8Brud%E6%93%8D%E4%BD%9C/</guid>
      <description>本文章涉及的知識  Springboot 、 Spring MVC HTTP method RESTful API JDBC mySQL語法 Html、css（小部分） Javascript 、Jquery、vue（小部分）  上一次的進度 [Spring Boot 管理會員資料（一）-會員創建](https://yen0304.github.io/p/spring-boot-%E7%AE%A1%E7%90%86%E6%9C%83%E5%93%A1%E8%B3%87%E6%96%99%E4%B8%80-%E6%9C%83%E5%93%A1%E5%89%B5%E5%BB%BA/#%E8%B3%87%E6%96%99%E5%BA%AB%E9%80%A3%E7%B7%9A%E8%A8%AD%E5%AE%9A-%E4%BD%BF%E7%94%A8jdbc)
上次的進度用到了CRUD操作中的Create,創建了會員資料，這次就做完剩下的Read、Update、Delete功能，所以HTTP method以及RESTful API的部分請參照上一章節
為了閱讀方便，附上一些本章節會使用到的資訊
Member Class:
public class Member { Integer id; @NotBlank String name; @NotBlank String account; @NotBlank String password; //Getter&amp;amp;Setter  } 本章節Dao Interface、Service Dao＆Implement Dao public interface MemberDao { //返回值 依據名稱對應資料庫動作（參數類型 參數名稱）  String CreatMember(Member member); List&amp;lt;Member&amp;gt; ReadMember(); List&amp;lt;Member&amp;gt; ReadByAccount(String membersAccount); String UpdateByAccount(String membersAccount,Member member); String DeleteByAccount(String membersAccount); } Service public interface MemberService { String CreatMember(Member member); List&amp;lt;Member&amp;gt; ReadMember(); List&amp;lt;Member&amp;gt; ReadByAccount(String membersAccount); String DeleteByAccount(String membersAccount); String UpdateByAccount(String membersAccount,Member member); } ServiceImpl @Component public class MemberServiceImpl implements MemberService{ @Autowired//使用InterFace 發揮spring Ioc特性  private MemberDao memberDao; @Override public String CreatMember(Member member) { return memberDao.</description>
    </item>
    
    <item>
      <title>Spring Boot 管理會員資料（一）-會員創建 CRUD-Create</title>
      <link>https://yen0304.github.io/p/spring-boot-%E7%AE%A1%E7%90%86%E6%9C%83%E5%93%A1%E8%B3%87%E6%96%99%E4%B8%80-%E6%9C%83%E5%93%A1%E5%89%B5%E5%BB%BA-crud-create/</link>
      <pubDate>Fri, 20 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yen0304.github.io/p/spring-boot-%E7%AE%A1%E7%90%86%E6%9C%83%E5%93%A1%E8%B3%87%E6%96%99%E4%B8%80-%E6%9C%83%E5%93%A1%E5%89%B5%E5%BB%BA-crud-create/</guid>
      <description>本文章涉及的知識  Springboot 、 Spring MVC HTTP method RESTful API JDBC mySQL語法 Html、css（小部分） Javascript 、Jquery（小部分）  複習HTPP method-GET or POST 差別 GET 或 POST 的差別最大的差別在於傳遞的參數會被看見，因為參數會放在url裡面。
POST的話參數會放在request body裡面，request body裡面通常會用Json格式來進行前後端的溝通
在Spring Boot裡面，使用@RequestBody取得放在request body的參數
練習設計RESTful API RESTful API三大原則： 1.使用http method表示動作
   HTTP Method 對應資料動作     POST Create（新增）   GET Read（查詢）   PUT Update（修改）   DELETE Delete（刪除）    2.url路徑表示資源階層關係
3.response body返回json或是xml格式
設計本範例RESTful API 設計會員資料之class public class Member { Integer id; String name; String account; String password; //getter &amp;amp; setter }    Method Url 資料庫 意義     POST /members Create（新增） 創建會員   GET /members/abc123 Read（查詢） 查詢會員帳號為abc123的資料   PUT /members/abc123 Update（修改） 修改會員帳號為abc123的資料   DELETE /members/abc123 Delete（刪除） 刪除會員帳號為abc123的資料    驗證請求參數 @NotBlank 為了讓使用者的登入數值不能為空白，避免後端程式發生錯誤，可以用此方法提前一部將錯誤回報給前端。</description>
    </item>
    
    <item>
      <title>Spingboot&#43;Freemarker基本配置</title>
      <link>https://yen0304.github.io/p/spingboot-freemarker%E5%9F%BA%E6%9C%AC%E9%85%8D%E7%BD%AE/</link>
      <pubDate>Sun, 08 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yen0304.github.io/p/spingboot-freemarker%E5%9F%BA%E6%9C%AC%E9%85%8D%E7%BD%AE/</guid>
      <description>前言 Springboot + Freemaker 基本設置 前端複習的差不多了，所以來試試如何將後端數據傳到前，在google的幫助下，瞭解了要用搜尋關鍵字Springboot + Freemaker，Freemaker 跟thymeleaf是差不多功能的東西，雖然Springboot官方是推薦使用thymeleaf，但網路上比較上是Freemaker勝出，且在設定上好像較容易，所以就使用Freemaker作為模板引擎了
在網路上的資源很多，從官方到個人網站都有教學，大同小異，但是到了最後連結上還是出了小問題，幸好最終解決了，所以在這紀錄一下架設過程，希望大家需要時能按圖施工保證成功！！
環境介紹 開發平台：IntelliJ 2020.3
Springboot版本：2.3.7.release
前端：html、css、皆快速使用bootstrap
1.maven添加Freemaker &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-boot-starter-freemarker&amp;lt;/artifactId&amp;gt; &amp;lt;/dependency&amp;gt; 2.檔案路徑&amp;amp;Freemaker環境配置 接下來檔案路徑就很重要了，
步驟1.
將自己index.html檔案放在resources/templates裡面，步驟是將檔案拉進去resources/templates後，intellij會詢問檔案名稱，這時候把副檔名改成ftl
接著要修改模板預設參數，在application.properties裡打上以下程式碼
spring.freemarker.cache=false# 模版後綴名 默認為ftlspring.freemarker.suffix=.ftl# 文件編碼spring.freemarker.charset=UTF-8# 模版加載的目錄spring.freemarker.template-loader-path=classpath:/templates/步驟2.
css、js檔案放在resources/static底下，切記，**一定要在static下新增css以及js資料夾！**否則會無法成功取得（我就是在這邊卡很久）。
3.測試用程式碼 接著新增controller,並使用getmapping
如下：
@Controller public class Logincontroller { @GetMapping(&amp;#34;/page&amp;#34;) public String show(Model model) { model.addAttribute(&amp;#34;name&amp;#34;,&amp;#34;測試&amp;#34;); return &amp;#34;/index&amp;#34;; } } 這邊要注意的地方是，
return &amp;#34;/index&amp;#34;; return的值就是ftl的檔案名稱
接著到index.ftl到隨便一個地方 加入 ${name} 來測試
我的長這樣：
&amp;lt;label&amp;gt; &amp;lt;input type=&amp;#34;checkbox&amp;#34; value=&amp;#34;remember-me&amp;#34;/&amp;gt; ${name} &amp;lt;/label&amp;gt; 4.檔案結構＆成果 這邊附上完整的檔案路徑配置
 
運行成果：</description>
    </item>
    
  </channel>
</rss>
