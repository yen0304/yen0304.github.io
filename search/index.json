[{"content":"GIT學習筆記－從初始化到上傳至遠端數據庫 前言 在看工作的時候，發現很多公司都希望擁有git的經驗，雖然有過使用Github Desktop的經驗，但是還是想知道背後的原理，所以就開始上網查資料學習了。\n可以參考這位六角學院的老師文章還有YT影片，實在是免費又大碗（淚。\n安裝＆測試 用終端機使用brew安裝git：\nInstall command:\nbrew install git 測試：\n打開終端機，輸入 git --version\n➜ ~ git --version git version 2.34.1 就代表安裝成功了\nGit基礎操作 首先這邊學習到終端機的使用，可以快速的移動到專案資料夾，\n設定個人資訊 git config --global user.name \u0026#34;您的姓名\u0026#34; git config --global user.email \u0026#34;您的Email\u0026#34; 查詢設定是否成功 git config --list 成功顯示之後按下q離開\n新建數據庫(Repository) 在電腦新增資料夾後，透過cd前往，在執行git指令$ git init，\n$ git init 接著到資料夾，並顯示隱藏檔案，就會看到.git資料夾了。\n接著到了\n版控流程  開新資料夾，git init 建立數據庫 新增一個 index.html 檔案  接著輸入git status\n到這裡應該會出現：\n 結果 \n可以看到終端機告訴我們；\n➜ gitTest git:(master) git status 位於分支 master 尚無提交 未追蹤的檔案: （使用 \u0026#34;git add \u0026lt;檔案\u0026gt;...\u0026#34; 以包含要提交的內容） index.html 提交為空，但是存在尚未追蹤的檔案（使用 \u0026#34;git add\u0026#34; 建立追蹤） 意思就是偵測到了檔案，但是他不是git所追蹤的對象，那就照他所說的\n將檔案加入到索引 git add \u0026lt;檔案名稱\u0026gt; 如果要將全部未追蹤加入索引的全部加入，\ngit add . 結果\n➜ gitTest git:(master) ✗ git status 位於分支 master 尚無提交 要提交的變更： （使用 \u0026#34;git rm --cached \u0026lt;檔案\u0026gt;...\u0026#34; 以取消暫存） 新檔案： index.html 可以看到從「未追蹤的檔案」變成「要提交的變更」（英文的話是Untracked files變成Changes to be committed）\n填寫版本資訊 git commit -m \u0026#34;\u0026lt;填寫版本資訊\u0026gt;\u0026#34; 輸入git commit -m \u0026quot;新增網頁\u0026quot;\n➜ gitTest git:(master) ✗ git commit -m \u0026#34;新增網頁\u0026#34; [master (根提交) 03dcd4c] 新增網頁 1 file changed, 0 insertions(+), 0 deletions(-) create mode 100644 index.html 再使用git status查看\n位於分支 master 沒有要提交的檔案，工作區為乾淨狀態 查詢歷史紀錄 git log 輸出：\ncommit 03dcd4c0bbd54f72a67aaaf74092eb454b981957 (HEAD -\u0026gt; master) Author: a＊＊＊＊＊＊3 \u0026lt;a＊＊＊＊＊3@gmail.com\u0026gt; Date: Mon Jan 10 16:59:05 2022 +0800 新增網頁 (END) 一樣小寫q退出。\n總結 目前實現了：\n 來源  學習了：\nGit 是如何追蹤檔案變化的\n 當我們建立數據庫後，立即新增一個檔案時，用 git status 查詢，會發現它是在 Untracked 狀態。 這就表示此檔案還沒進到版本控制，藉由 git add . 將檔案加入到索引 (Staged) 後，準備提交成一個 commit 版本。 藉由 git commit -m \u0026lt;提交訊息\u0026gt; 後，該檔案就會開始被追蹤，檔案狀態就會變成 UnModified 狀態。   3 \n接著稍微練習一下，\n新增兩個檔案，並查詢狀態，並用git add .開起全部追蹤\n➜ gitTest git:(master) ✗ git status 位於分支 master 未追蹤的檔案: （使用 \u0026#34;git add \u0026lt;檔案\u0026gt;...\u0026#34; 以包含要提交的內容） all.css all.js 提交為空，但是存在尚未追蹤的檔案（使用 \u0026#34;git add\u0026#34; 建立追蹤） ➜ gitTest git:(master) ✗ git add * ➜ gitTest git:(master) ✗ git status 位於分支 master 要提交的變更： （使用 \u0026#34;git restore --staged \u0026lt;檔案\u0026gt;...\u0026#34; 以取消暫存） 新檔案： all.css 新檔案： all.js ➜ gitTest git:(master) ✗ git commit -m \u0026#34;加入兩個檔案css\u0026amp;js\u0026#34; [master ab3e252] 加入兩個檔案css\u0026amp;js 2 files changed, 0 insertions(+), 0 deletions(-) create mode 100644 all.css create mode 100644 all.js ➜ gitTest git:(master) git status 位於分支 master 沒有要提交的檔案，工作區為乾淨狀態 ➜ gitTest git:(master) Sourcetree Sourcetree是一個介面圖形化的軟體，讓我們可以用點擊的方式來完成git指令。\n可以在介面上看到有一個new repository點擊之後再按Add Existing Local Repository，打開已經建立好的數據庫。\n \n選擇我們剛剛所建立的資料夾之後，就會看到上面畫面中多了一個數據庫可以選擇，點擊右鍵兩下，就可以看到數據庫的資訊了，如下圖：\n \n當我們把程式進行改變、新增檔案可以看多了\nUncommitted changes的選項，也可以看到檔案路徑被改變、或是新增哪些程式碼的資訊\n \n這時候，這些檔案的位置還在工作目錄，也就是尚加入索引Uncommitted\n \n所以要透過git add .來加入索引，在sourcetree想要進行add操作來加入commit，只要將要加入索引的檔案打勾，在按下commit按鍵，就會跳到commit畫面。\n \n接著在下面設定好我們要commit的名稱，並按下藍色commit\n \n上面的操作即等於\ngit commit -m \u0026#34;新增h1標題更改路徑\u0026#34; 就成功了\n新增遠端數據庫 repo 在github新增資料庫就像我們在github執行git init一樣，\n所以到github new repository之後，可以看到github給了一些git指令\n \n接著複製\ngit remote add origin https://github.com/yen0304/test.git到終端機並執行後，雖然乍看之下沒有變化，但是到隱藏的資料夾後，打開config檔案，看到origin就代表成功了。\n \n再來看到push的指令\ngit push -u origin 輸入帳號密碼就成功了，那我是使用SSH的方式， 可以按照這篇文章來設定公鑰來使用，這樣就不用輸入帳號密碼了！\n  he list of known hosts. 枚舉物件: 10, 完成. 物件計數中: 100% (10/10), 完成. 使用 8 個執行緒進行壓縮 壓縮物件中: 100% (6/6), 完成. 寫入物件中: 100% (10/10), 995 位元組 | 995.00 KiB/s, 完成. 總共 10 (差異 0)，復用 0 (差異 0)，重用包 0 To github.com:yen0304/test.git * [new branch] master -\u0026gt; master 分支 \u0026#39;master\u0026#39; 設定為追蹤來自 \u0026#39;origin\u0026#39; 的遠端分支 \u0026#39;master\u0026#39;。   接著回到github，就可以看到檔案完成上傳了！\n \n那之後如果進行程式碼更改的時候，從Sourcetree可以看到\nMaster 還有 Origin/Master， 這兩者Master所代表的是本地端的commit，Origin/master則是遠端數據庫的commit。\n \n到了這邊，就可以自行使用git來進行版本控制了， 接下來就要學會如何與團隊共同使用git。\nGITHUB 如果需要文章中的檔案，可以到https://github.com/yen0304/test來下載。\n","date":"2022-01-14T00:00:00Z","image":"https://yen0304.github.io/p/git%E5%AD%B8%E7%BF%92%E7%AD%86%E8%A8%98%E5%BE%9E%E5%88%9D%E5%A7%8B%E5%8C%96%E5%88%B0%E4%B8%8A%E5%82%B3%E8%87%B3%E9%81%A0%E7%AB%AF%E6%95%B8%E6%93%9A%E5%BA%AB/logo_hu0871f2e332734283fcd708b643f05707_22105_120x120_fill_q75_box_smart1.jpeg","permalink":"https://yen0304.github.io/p/git%E5%AD%B8%E7%BF%92%E7%AD%86%E8%A8%98%E5%BE%9E%E5%88%9D%E5%A7%8B%E5%8C%96%E5%88%B0%E4%B8%8A%E5%82%B3%E8%87%B3%E9%81%A0%E7%AB%AF%E6%95%B8%E6%93%9A%E5%BA%AB/","title":"GIT學習筆記－從初始化到上傳至遠端數據庫"},{"content":"SpringBoot學習筆記-單元測試(4)-Mockito 前言 部分文章內容來自於古老師在hahow的課程，還有古老師的部落格，想要做筆記的原因是因為，邊記變做會比較容易記住，改天忘了也可以用自己的方式去理解。\nMock測試目的與特性 單元測試的特性為下：\n1.可以被自動化運行\n2.各個單元測試互相獨立，彼此之間不能有依賴關係\n3.測試結果穩定，不受外部服務影響\n在前面的筆記，如果要測試Service層的話，應該會這樣寫：\n@SpringBootTest public class StudentServiceImplMockTest { @Autowired StudentService studentService; @Test public void getById(){ Student student=studentService.getById(3); assertNotNull(student); assertEquals(3,student.getId()); assertEquals(\u0026#34;Judy\u0026#34;,student.getName()); } } 在上面的測試單元裡，StudentService其實用到了StudentDao這個Bean，\n並不符合地２點，Bean之前在上面是有依賴關係的，所以Mock測試的\n 目的：避免測試某一個單元測試，而去建構整個bean的依賴。 作法：創造一個假的bean，替換掉容器原有的bean。  在程式裡面Mock的意思為「假的」的意思，而非英文單字模仿。\nMockito Mockito是Spring Boot中，進行Mock測試的工具\n功能大致上分為：\n 模擬方法的返回值 模擬拋出Exception 記錄方法的使用次數、順序  @MockBean @Test public void getById(){ //第二步  Student mockStudent = new Student(); mockStudent.setId(100); mockStudent.setName(\u0026#34;mockname\u0026#34;); //這句話的意思就是，當有人使用studentDao.getById(3)時，固定return mockStudent這個object  Mockito.when(studentDao.getById(3)).thenReturn(mockStudent); Student student=studentService.getById(3); assertNotNull(student); assertEquals(3,student.getId()); assertEquals(\u0026#34;Judy\u0026#34;,student.getName()); } 執行結果：\norg.opentest4j.AssertionFailedError: Expected :3 Actual :100 再把\nassertEquals(3,student.getId());改成assertEquals(3,student.getId());就會顯示測試成功了\n使用MockBean注意事項 承上，如果把Student student=studentService.getById(3)改成了Student student=studentService.getById(2)下面的單元測試依然會運行錯誤，原因是因為在沒有定義返回值是多少的情況下，這個假的mockbean預設會傳NULL\n@Test public void getById(){ Student mockStudent = new Student(); mockStudent.setId(100); mockStudent.setName(\u0026#34;mockname\u0026#34;); Mockito.when(studentDao.getById(3)).thenReturn(mockStudent); Student student=studentService.getById(2); assertNotNull(student); assertEquals(3,student.getId()); assertEquals(\u0026#34;Judy\u0026#34;,student.getName()); } 所以我們會利用\nMockito.any() 來固定返回mockStudent這個數值\n由Mockito.when(studentDao.getById(3)).thenReturn(mockStudent);\n變成Mockito.when(studentDao.getById(Mockito.any())).thenReturn(mockStudent);\n這樣不論參數是多少，都還是會固定返回mockStudent出來。\n補充thenReturn doReturn 其實只是寫法上的不同，下面的程式碼是等價的\nMockito.when(studentDao.getById(Mockito.any())).thenReturn(mockStudent); Mockito.doReturn(mockStudent).when(studentDao.getById(Mockito.any())); Throw Expection Mockito.when(studentDao.insert(Mockito.any())).thenThrow(new RuntimeException()); Mockito.doThrow(new RuntimeException()).when(studentDao).deleteById(Mockito.any()); Verify 用來記錄方法的使用次數、順序（少用）\nMockito.doThrow(new RuntimeException()).when(studentDao).deleteById(Mockito.any()); Mockito 的限制 上述就是 Mockito 的 mock 對象使用方法，不過當使用 Mockito 在 mock 對象時，有一些限制需要遵守\n  不能 mock 靜態方法\n  不能 mock private 方法\n  不能 mock final class\n  ","date":"2022-01-12T00:00:00Z","image":"https://yen0304.github.io/p/springboot%E5%AD%B8%E7%BF%92%E7%AD%86%E8%A8%98-%E5%96%AE%E5%85%83%E6%B8%AC%E8%A9%A64-%E4%BD%BF%E7%94%A8mockito%E4%BE%86%E6%B8%9B%E5%B0%91%E5%96%AE%E5%85%83%E6%B8%AC%E8%A9%A6%E4%B8%AD%E7%9A%84bean%E4%BE%9D%E8%B3%B4/logo_hud02855c89443ca066a520da3d79109c3_149566_120x120_fill_box_smart1_3.png","permalink":"https://yen0304.github.io/p/springboot%E5%AD%B8%E7%BF%92%E7%AD%86%E8%A8%98-%E5%96%AE%E5%85%83%E6%B8%AC%E8%A9%A64-%E4%BD%BF%E7%94%A8mockito%E4%BE%86%E6%B8%9B%E5%B0%91%E5%96%AE%E5%85%83%E6%B8%AC%E8%A9%A6%E4%B8%AD%E7%9A%84bean%E4%BE%9D%E8%B3%B4/","title":"SpringBoot學習筆記-單元測試(4)-使用Mockito來減少單元測試中的Bean依賴"},{"content":"SQL學習筆記(3)-水平合併(JOIN ON)與垂直合併(UNION) 前言 本系列大多部分來自Hahow的課程－SQL的50道練習，學習過程中得到的筆記，文章內容也有部份都是從教材擷取出來，如果有興趣可以去上課看看。\n那這章的基本語法其實網路上的網站fooish都講得蠻完善的了，部分文章內容也會引用網站文章內容。\n網路上有人說程式會忘記是很正常的，也因為這次JOIN ON的用法很有趣，所以這次的文章比較多是自己做的圖片，或是個人見解，我希望把程式用白話的方式一一來理解，讓自己能真正的理解他。\n開發環境 電腦系統：macOS（Big Sur）\n資料庫管理工具：DBeaver\n使用語言：SQLite\nJOIN ON 水平合併 在JOIN功能中，SQLite分為LEFT JOIN ON以及JOIN ON，但其實差別不大，LEFT JOIN ON的意思是希望保留以左側觀測值為主的資料，但一般來說都會指定要顯示的資料來自於哪個資料表， 所以在SQL中就只有LEFT JOIN ON而沒有JOIN ON。\n格式 概念圖： \nSELECTleft_table.column_names,right_table.column_namesFROMtable_nameASleft_tableLEFTJOINtable_nameASright_tableONleft_table.join_key=right_table.join_key;實際使用情境舉例 水平合併的作用在於，今天如果有兩個資料表，一個是\n以及學生個人資料表table1資料表，其中裡面存放學生的學號number以及姓名name\n學生的考試成績table2資料表，其中存放成績score以及學號number\n所以我們想要顯示學生的成績以及姓名時，就需要把兩個欄位一起合併再來顯示，\n概念大概是這樣：\n   number name  number score  number name score     1 A + 1 90 = 1 A 90   2 B + 2 100 = 2 B 100   3 C + 3 80 = 3 C 80    上面的例子來說，我們要合併的關鍵是兩個資料表所擁有一樣定義的值，這個值在資料庫的實體關係圖（ER Diagram, Entity Relationship Diagram）找到，這些值就是來自於元資料的定義，那在上面的例子中就是學生的學號，這時學號我們就會稱為他為結合鍵（Join Key），\n撰寫流程 在流程上\n1.可以先決定左側表格\nSELECTFROMtable1---先決定有學生學號的左側表格 2.決定右側要合併的表格，以及跟左側表格合併的結合鍵\nLEFTJOINtable2--要合併的表格 ONtable2.number=table1.number--結合鍵 ３.結合1+2之後，寫上SELECT後面要選擇顯示的資料\nSELECTtable1.number,table1.name,table2.scoreFROMtable1LEFTJOINtable2--要合併的表格 ONtable2.number=table1.number--結合鍵 就完成了，\n再來看比較複雜的應用\n進階使用 在50道連習題當中，有一題目如下：\n從 nba 資料庫查詢各個球隊的得分王（生涯場均得分 ppg 全隊最高）是誰，將查詢結果依隊伍名排序，參考下列的預期查詢結果。\n team player ppg 0 Atlanta Hawks Trae Young 24.0 1 Boston Celtics Kemba Walker 19.8 2 Brooklyn Nets Kevin Durant 27.1 3 Charlotte Hornets LaMelo Ball 15.9 4 Chicago Bulls Zach LaVine 18.8 5 Cleveland Cavaliers Collin Sexton 19.7 6 Dallas Mavericks Luka Doncic 25.6 7 Denver Nuggets Nikola Jokic 18.0 8 Detroit Pistons Josh Jackson 12.0 9 Golden State Warriors Stephen Curry 23.8 10 Houston Rockets John Wall 19.0 ​\nER圖：\n \n分析 Career_summaries資料表記錄著用球員id「personId」來做主鍵，裡面放著有關於得分的資料，再來players資料表裡面用「personId」記錄著球員的姓名以及其他球員資料還有所屬球隊的id「teamId」，再來teams資料表裡面用「teamId」記錄著隊伍的資料，所以我們先把希望呈現出來的成果分為左右表格分析，\n可以從預期結果裡面來規劃，隊伍連結球員，球員連結得分\n撰寫流程 1.在最左側的隊伍名稱在隊伍裡面，所以：\nSELECTFROMteams2.再來用裡面的teamId來連結players資料表，也因為球員資料裡面記錄著所屬球隊的id：\nSELECT--1. FROMteamsLEFTJOINplayers--2. ONteams.teamId=players.teamId3.再來，要連結球員個人資料表players，他跟Career_summaries資料表可以用記錄著用球員id「personId」來跟players 資料表中的teamId 做結合鍵。\nLEFTJOINteams--加入 ONplayers.personId=career_summaries.personId4.1+2+3變成了：\nSELECT--1. FROMteamsLEFTJOINplayers--2. ONteams.teamId=players.teamIdLEFTJOINteams--加入 --3 ONplayers.personId=career_summaries.personId5.再來會要使用聚合函數MAX來取ppg的最大值，所以一想到聚合函數還有隊伍，就會想到分組的GROUP BY\n所以：\nSELECTteams.fullNameASteam,players.firstName||\u0026#39; \u0026#39;||players.lastNameASplayer,MAX(career_summaries.ppg)FROMteamsLEFTJOINplayersONteams.teamId=players.teamIdLEFTJOINteams--加入 ONplayers.personId=career_summaries.personIdGROUPBYteams.teamIdUNION 垂直合併 垂直合併簡單多了，他跟子查詢很像，就是位於資料表上方的SQL語句放UNION上面，要從下方合併的放UNION下面，\nASELECTstatementUNIONAnotherSELECTstatement使用 UNION 的注意事項  垂直合併的欄位數要相同。（如果沒有會產生error) 垂直合併的 SQL 若有使用到 ORDER BY 只能放在 UNION 之後。 垂直合併的重複觀測值會被省略。  如果不要省略重複的觀測值，使用\nUNION ALL ASELECTstatementUNIONALLAnotherSELECTstatement就可以了\n 垂直合併示意圖 \n水平合併＆垂直合併的進階使用 在50道連習題當中，有一題目如下：\n從twElection2020 資料庫查詢中國國民黨、民主進步黨與親民黨在不分區立委與區域立委的得票率，參考下列的預期查詢結果。\nPS 不分區立委的投票資料記錄於資料表 legislative_at_large\n，區域立委的投票資料記錄於資料表 legislative_regional。\n預期輸出結果：\n   party election votes_percentage     中國國民黨 不分區立委 0.3336   民主進步黨 不分區立委 0.3338   親民黨 不分區立委 0.0366   中國國民黨 區域立委 0.4071   民主進步黨 區域立委 0.4511   親民黨 區域立委 0.0043    ​\n首先，先觀察個資料表\nER圖：\n ER圖 \n這題要先知道\n不分區立委：簡單說就是政黨的得票，投黨不投人\n所以不分區的比較簡單，連接兩種table就好，連結政黨parties資料表，再來這個資料表裡面存放黨派的id「id」，還有政黨名字「party」,透過存放政黨票的資料表 legislative_at_large，有得票數vote以及得票的政黨id「partyid」。\n所以結合鍵就是政黨的id，\n然後中間用UNION隔開，再來看區域立委：\n再來是區域立委：投人的，\n所以分區立委的投票率計算方法是：黨派裡面的所有所屬立委的得票數總和，要連接三張table，第一張是黨派的id名單，再來是立委所屬的黨派，再來是立委得票結果，\n詳細解答：\nSELECTparties.party,\u0026#39;不分區立委\u0026#39;election,--4. ROUNCAST(SUM(legislative_at_large.votes)ASREAL)/(SELECTSUM(votes)--5 FROMlegislative_at_large),4)ASvotes_percentageFROMparties--在最左邊的「黨派」 JOINlegislative_at_large--1.先設定好右側連結表 ONparties.id=legislative_at_large.party_id--2.連結條件 WHEREparties.partyIN(\u0026#39;中國國民黨\u0026#39;,\u0026#39;民主進步黨\u0026#39;,\u0026#39;親民黨\u0026#39;)--3.直接篩選特定黨派 GROUPBYparties.partyUNION-------------------垂直相加第一步，複製上面跟下面，中間用UNION隔開 SELECTparties.party,\u0026#39;區域立委\u0026#39;ASelection,ROUND(CAST(SUM(legislative_regional.votes)ASREAL)/(SELECTSUM(legislative_regional.votes)--6 FROMlegislative_regional),4)ASvotes_percentage--6 FROMparties--1左邊的黨派 JOINcandidates--2.要先得知立委所屬黨派，目標是黨派LINK立委LINE立委編號 ONparties.id=candidates.party_id--3.條件(得知立委所屬黨派，黨派表連結立委黨派表） JOINlegislative_regional--4.加入立委得票數（立委黨派表連結立委得票數表） ONcandidates.id=legislative_regional.candidate_id--5.立委個人id-立委得票id連結 WHEREparties.partyIN(\u0026#39;中國國民黨\u0026#39;,\u0026#39;民主進步黨\u0026#39;,\u0026#39;親民黨\u0026#39;)GROUPBYparties.partyORDERBYelection;--垂直相加第二步，排版 差不多就是這樣！\n","date":"2022-01-12T00:00:00Z","image":"https://yen0304.github.io/p/sql%E5%AD%B8%E7%BF%92%E7%AD%86%E8%A8%983-%E6%B0%B4%E5%B9%B3%E5%90%88%E4%BD%B5join-on%E8%88%87%E5%9E%82%E7%9B%B4%E5%90%88%E4%BD%B5union/logo_hue91c0a6a1fc261792a7714a8d89d8466_163197_120x120_fill_q75_box_smart1.jpeg","permalink":"https://yen0304.github.io/p/sql%E5%AD%B8%E7%BF%92%E7%AD%86%E8%A8%983-%E6%B0%B4%E5%B9%B3%E5%90%88%E4%BD%B5join-on%E8%88%87%E5%9E%82%E7%9B%B4%E5%90%88%E4%BD%B5union/","title":"SQL學習筆記(3)-水平合併(JOIN ON)與垂直合併(UNION)"},{"content":"SQL學習筆記(2)-分組與聚合結果篩選、子查詢 前言 本系列大多部分來自Hahow的課程－SQL的50道練習，學習過程中得到的筆記，文章內容也有部份都是從教材擷取出來，如果有興趣可以去上課看看。\n那這章的基本語法其實網路上的網站fooish都講得蠻完善的了，部分文章內容也會引用網站文章內容。\n但這次的文章比較多是自己做的圖片，或是個人見解，我希望把程式用白話的方式一一來理解，讓自己能真正的理解他。\n開發環境 電腦系統：macOS（Big Sur）\n資料庫管理工具：DBeaver\n使用語言：SQLite\nGROUP BY GROUP BY是一個很重要的敘述句，常常搭配聚合函數(aggregate_function)使用，\n下面的aggregate_function(column_name) ，代表使用的聚合函數以及要進行計算的column的名字\nWHERE條件篩選則是看場合使用，\nGROUP BY 後面如果放了多個column，代表將這些結果越分越細，同時他也具有ORDER BY的功能。\nSELECTcolumn_name(s),aggregate_function(column_name)FROMtable_nameWHEREcolumn_nameoperatorvalueGROUPBYcolumn_name1,column_name.2;詳細解說如下\n 自己做的\u0026gt;\u0026lt; \n因為GROUP BY每一個群組會傳回一個資料列，所以自然而然就按照了預設的順序排出了第一筆資料。\n但其實這時候分組已經完成了，再看下一張圖：\n \nGROUP BY可以想像成把指定的column合併分組之後，但實際上是有展開功能的，裡面的數據並不會消失，\n所以如果我們要計算每個組別的價錢總和，就使用GROUP BY 組別名稱 在使用聚合函數SUM(columm)，把價錢加總起來，如果在GROUP BY 之後加上的是GROUP BY column_name1, column_name.2，就可以假設在 column_name1之後還有column_name.2分組結果可以展開。\n聚合函數COUNT() SELECTCOUNT(column_name)FROMtable_name;COUNT(column_name) 函數用來計算符合查詢條件的欄位紀錄總共有幾筆。\n這裡其實需要去理解一下，其實COUNT(column_name)返回的是在指定的column中，欄位值不為NULL的數量，\n所以換句話說，如果有NULL值的話並不會被算進去，所以一般不會把有NULL的值放進去做計算，但反觀，\n如果都不為NULL的話，就被大家拿來當作查看欄位值有幾筆的函數了，畢竟每個都有值的話，白話說就是數有幾筆數量，但如果在資料表觀測值都不為NULL的情況下，大家的筆數都會一樣，所以這時候就會變成我們常用的\nCOUNT()或是COUNT(*)，意思都一樣。\n當COUNT遇上GROUP BY 這是個超常會碰到的用法，在資料皆不為null的情況下，\nCOUNT的意思是「有幾筆資料」 ，\nGROUP的意思則是「分組」\n合起來用變成，「分組的組別有幾筆資料」。\n範例  moives資料表（部分） \n在50道練習當中，某一道題目如下\n從 imdb 資料庫的 movies 資料表計算每一年有幾部在 IMDb.com\n獲得高評等的經典電影，參考下列的預期查詢結果。\n從上面我們可以知道要如何解題\n 首先寫上 SELECT FROM movies，先選好要顯示資料在哪一個資料表 接著要計算「每一年」，所以我們把年進行分組GROUP BY release_year 再來使用COUNT(*)計算每一組的比數，意思就是在GROUP BY release_year以年分組後展開後有幾筆數量，也因為大家都不為NULL，所以這個數字也變成了有幾部電影的數量 選擇其他要顯示SELECT release_year,COUNT(*) AS number_of_movies  合起來變成：\nSELECTrelease_year,COUNT(*)ASnumber_of_moviesFROMmoviesGROUPBYrelease_year結果如下：\n gpc1 \nHAVING HAVING跟WHERE一樣都是做條件篩選，但HAVING 後面可以放聚合函數，但WHERE不行，也因為這樣的特性\n我們可以把它想成\nHAVING是「先計算後篩選」,WHERE則是「先篩選後計算」\nSELECTcolumn_name(s),aggregate_function(column_name)FROMtable_nameWHEREcolumn_nameoperatorvalueGROUPBYcolumn_name1,column_name2...HAVINGaggregate_function(column_name)operatorvalue;範例：\n   O_Id Price Customer     1 1000 張一   2 2000 王二   3 500 李三   4 1300 張一   5 1800 王二    SELECTCustomer,SUM(Price)FROMordersGROUPBYCustomerHAVINGSUM(Price)\u0026lt;1000;在這邊，我們可以看到由GROUP BY Costomer以客人所進行的分組，以及SUM(Price)的加總，\n變成了計算每一個客人總共花了多少錢，但再加上HAVING SUM(Price)\u0026lt;1000，篩選總金額小於1000的值，所以段程式碼的意思是「顯示price總和小於1000的顧客(Customer)」\n結果：\n   Customer SUM(Price)     李三 500    但如果\nSELECTCustomer,SUM(Price)FROMordersGROUPBYCustomerWHEREPrice\u0026lt;1000在WHERE price先進行條件篩選後，這時候連SUM(Price)也不會列入計算，\n變成了「計算顧客單筆花費不超過1000的總和」，\n結果\n   O_Id Price Customer     1 2300 張一   2 3800 王二   3 0 李三    Leetcode題目182.(1/13更新) 在DB中Leetcode的182. Duplicate Emails題目如下：\n+-------------+---------+ | Column Name | Type | +-------------+---------+ | id | int | | email | varchar | +-------------+---------+ id is the primary key column for this table. Each row of this table contains an email. The emails will not contain uppercase letters Write an SQL query to report all the duplicate emails.\nReturn the result table in any order.\nThe query result format is in the following example.\nExample1.\nInput: Person table: +----+---------+ | id | email | +----+---------+ | 1 | a@b.com | | 2 | c@d.com | | 3 | a@b.com | +----+---------+ Output: +---------+ | Email | +---------+ | a@b.com | +---------+ Explanation: a@b.com is repeated two times. 意思就是要找出重複的email，\n所以我們可以利用GROUP BY選出重複數量，再利用HAVING先執行在篩選的概念，再把大於2的email count列印出來，解答：\nSELECTemailASEmailFROMPersonGROUPBYemailHAVINGCOUNT(email)\u0026gt;1子查詢 子查詢就是在一個Select指令內再放入一個Select查詢指令進行查詢，通常是位在Select的Where子句，可以透過子查詢取得查詢條件。\n簡單來說，如果我們想在WHERE後面的條件來自於資料表的值、查詢結果，所以通常這個子查詢SELECT後面的欄位只會一個(例如123)，因為我們不會在WHERE後面放 where a=（123,456 )這樣在語法上就錯誤了，\n使用子查詢撰寫流程技巧 假設我們今天要查詢最短的電影他的資料，\n我們要分兩次查詢來完成\n 先查詢「最短」的片長是幾分鐘。 再依據前一個查詢結果作為篩選條件。  SELECTMIN(runtime)ASminimum_runtime-- 先查詢「最短」的片長是幾分鐘。 FROMmovies;這時候，假設輸出是\n   minimum_runtime     45    所以第二次我們會使用\nSELECT*FROMmoviesWHEREruntime=45;-- 再依據前一個查詢結果作為篩選條件。 得出結果：\n   id title release_year rating director runtime     195 Sherlock Jr. 1924 8.2 Buster Keaton 45    接著再把45的地方取代成「取出45的sql語句」，記得加括號\nSELECT*FROMmoviesWHEREruntime=(SELECTMIN(runtime)ASminimum_runtimeFROMmovies;)Leetcode題目183.(1/13更新) 在183. Customers Who Never Order中，\n題目：\nWrite an SQL query to report all customers who never order anything.\nReturn the result table in any order.\nThe query result format is in the following example.\nInput: Customers table: +----+-------+ | id | name | +----+-------+ | 1 | Joe | | 2 | Henry | | 3 | Sam | | 4 | Max | +----+-------+ Orders table: +----+------------+ | id | customerId | +----+------------+ | 1 | 3 | | 2 | 1 | +----+------------+ Output: +-----------+ | Customers | +-----------+ | Henry | | Max | +-----------+ 意思就是要從顧客名單Customers table裡面，從Orders挑出還沒點餐的顧客\n這題如果我們在已知customerId的情況會這樣寫：\nSELECTa.nameASCustomersFROMCustomersASaWHEREa.idnotin(1,3)所以我們只要利用子查詢返回1.3就可以了！\nSELECTa.nameASCustomersFROMCustomersASaWHEREa.idnotin(SELECTcustomerIdFROMOrders)","date":"2022-01-11T00:00:00Z","image":"https://yen0304.github.io/p/sql%E5%AD%B8%E7%BF%92%E7%AD%86%E8%A8%982-%E5%88%86%E7%B5%84group-by%E8%88%87%E8%81%9A%E5%90%88%E5%87%BD%E6%95%B8%E7%B5%90%E6%9E%9C%E7%AF%A9%E9%81%B8%E5%AD%90%E6%9F%A5%E8%A9%A2/logo_hue91c0a6a1fc261792a7714a8d89d8466_163197_120x120_fill_q75_box_smart1.jpeg","permalink":"https://yen0304.github.io/p/sql%E5%AD%B8%E7%BF%92%E7%AD%86%E8%A8%982-%E5%88%86%E7%B5%84group-by%E8%88%87%E8%81%9A%E5%90%88%E5%87%BD%E6%95%B8%E7%B5%90%E6%9E%9C%E7%AF%A9%E9%81%B8%E5%AD%90%E6%9F%A5%E8%A9%A2/","title":"SQL學習筆記(2)-分組(GROUP BY)與聚合函數結果篩選、子查詢"},{"content":"SQL學習筆記(1)-資料查詢、獨顯一值、運算符、函數 前言 本系列大多部分來自Hahow的課程－SQL的50道練習，學習過程中得到的筆記，文章內容也有部份都是從教材擷取出來，如果有興趣可以去上課看看！\n那這張的基本語法其實網路上的網站fooish都講得蠻完善的了，部分文章內容也會引用網站文章內容。\n開發環境 電腦系統：macOS（Big Sur）\n資料庫管理工具：DBeaver\n使用語言：SQLite\nMySQL \u0026amp; SQLite差異 在語法中大多相同，所以SQLite對我的學習上是有幫助的，這兩者最大的差異主要是SQLite不支持網路訪問， 沒有伺服器的特性，但他也跟他的名字一樣，在設定、管理上都更加的輕盈、快速，有興趣可以到這個網路文章參考看看。\nSELECT、FROM SELECT 敘述句主要由兩部分構成，第一部分是要 \u0026ldquo;拿什麼\u0026rdquo; 資料 (若有多項用逗號隔開)；第二部分則為 \u0026ldquo;從哪拿\u0026rdquo;。\nSELECTtable_column1,table_column2,table_column3...FROMtable_name;這個應該不會有什麼問題！\n這裡table_column1, table_column2指的是要從資料表拿取col的名稱，table_name則是從哪一個資料表拿取。\nLIMIT 主要用來限制資料查詢的數量（number）\nSELECTtable_column1,table_column2...FROMtable_nameLIMITnumber;範例 在課程中，imdb.db的有一個名字叫movies的資料表（table）；\n如果想觀看資料表的全部可以搭配「＊」，「＊」意思是全選\nSELECT ＊ FROM movies 結果；\n   id title release_year rating director runtime     1 The Shawshank Redemption 1994 9.3 Frank Darabont 142   2 The Godfather 1972 9.2 Francis Ford Coppola 175   3 The Godfather: Part II 1974 9.0 Francis Ford Coppola 202   4 The Dark Knight 2008 9.0 Christopher Nolan 152   5 12 Angry Men 1957 9.0 Sidney Lumet 96    .\n.\n.\n   id title release_year rating director runtime     248 Tangerines 2013 8.2 Zaza Urushadze 87   249 Drishyam 2015 8.2 Nishikant Kamat 163   250 Swades 2004 8.2 Ashutosh Gowariker 189    如果只想顯示前三筆資料的話：\nSELECT*--SELECT是選擇欄位 FROMmovies--FROM代表指定從哪一個資料表查詢 LIMIT3;--LIMIT查詢結果顯示前幾列 結果：\n   id title release_year rating director runtime     1 The Shawshank Redemption 1994 9.3 Frank Darabont 142   2 The Godfather 1972 9.2 Francis Ford Coppola 175   3 The Godfather: Part II 1974 9.0 Francis Ford Coppola 202    AS語法 在 SQL 中我們可以替資料表或欄位名稱取一個別名 (Alias)，這可以使名稱複雜的 SQL 查詢語句更易讀且可以有更直觀的查詢結果。\n​\t在下面，alias_name表示的就是要取的別名，\nSELECTtable_column1,table_column2,table_column3...FROMtable_nameASalias_name;範例 還沒使用AS：\nSELECTfirstName,lastNameFROMplayersLIMIT5;結果：\n   firstName lastName     LeBron James   Carmelo Anthony   Udonis Haslem   Dwight Howard   Andre Iguodala    使用AS\nSELECTfirstNameASfirst_name,,lastNameASlast_nameFROMplayersLIMIT5;   firstname lastname     LeBron James   Carmelo Anthony   Udonis Haslem   Dwight Howard   Andre Iguodala    可以看到從查詢結果中col的名稱從firstName 改成了 first_name\nDISTINCT 一個資料表的某欄位中可能會有多個紀錄都是相同值的情況，在 SELECT 查詢語句中我們可使用 DISTINCT 關鍵字過濾重複出現的紀錄值。\nSELECTDISTINCTtable_column1,table_column2FROMtable_name;綜合SELECT、 FROM、AS、DISTINCT範例 在練習題08中，答案程式碼：\nSELECTDISTINCTconfName||\u0026#39;, \u0026#39;||divNameASconf_divFROMteams這邊的解釋就是，從資料表teams中，查詢出一筆confName再加上用「, 」跟divName合併的資料，這筆資料的名稱叫做conf_div，並且過濾掉重複的內容。\n查詢結果：\n   conf_div     East, Southeast   East, Atlantic   East, Central   West, Southwest   West, Northwest   West, Pacific    ORDER BY ORDER BY的能依照欄位來做排序，由ASC（遞增）或DESC（遞減）來決定遞增或遞減，預設是ASC，當ORDER BY有多欄位的時候，表示依照這些欄位在程式中的順序來排序\nSELECTtable_column1,table_column2...FROMtable_nameORDERBYcolumn_name1ASC|DESC,column_name2ASC|DESC...範例 SELECTDate,Country_Region,aily_CasesFROMtime_series--從time_series取出三筆資料Date,Country_Region ,aily_Cases ORDERBYDaily_CasesDESC--依照Daily_Cases按照遞減做排序 LIMIT10;--顯示前１０列 函數 函數可依照功能分為兩大類：  通用函數（Universal functions）  轉換資料類型。 計算數值。 操作文字。 操作日期時間。   聚合函數（Aggregate functions）  那其實如果要判斷是哪一種類型的函數的話，通用函數作用在「水平」方向的結果，聚合函數作用在「垂直」方向的結果。\n通用函數 CAST 使用 CAST 函數可以將查詢結果的資料類型轉換為指定資料類型\ndata是要轉換的資料，data_type則是轉換的資料類型\nCAST(dataASdata_type)CAST常用知識： 在sql中，兩過整數相除的時後結果只會是整數，如果想要顯示小數點的話，在做除法的時候，可以將「分子或分母其中之一」轉成REAL就可以顯示小數點\nCOALESCE 使用 COALESCE 函數可以將空值（或稱遺漏值）轉換為指定常數\n這邊，field_name可以是欄位名稱，也可以是函數計算的結果，如果為null的話將會取代成replacement\nCOALESCE(field_name,replacement)ROUND 使用 ROUND 函數可以調整查詢結果的小數點位數\nn_digits＝小數點第幾為\nROUND(REAL,n_digits)LENGTH 使用 LENGTH 函數可以計算文字中有幾個字元，包含空格、標點符號\nTEXT裡面放TEXT的參數：\nLENGTH(TEXT)LOWER ＆ UPPER 使用 LOWER 與 UPPER 函數可以調整英文的大小寫\nLOWER(TEXT)UPPER(TEXT)STRFTIME 在這部分，sqLite跟mySql的差別較大，sql可以參考官方文件的格式參數來調整顯示的格式，但mysql則是靠函數來操作，\nSQLite 使用 STRFTIME 函數調整日期、時間或日期時間的顯示格式，\nformat是要顯示的格式，DATE/TIME/DATETIME則是要顯示的來源，\nSTRFTIME(format, DATE/TIME/DATETIME) 詳細用法參考網站\n常見的日期與日期時間格式參數\n %d：二位數的日（01-31） %j：一年中的第幾天（001-366） %m：二位數的月（01-12） %w：一星期中的第幾天（0-6） %W：一年中的第幾週（00-53） %Y：四位數的年（0000-9999）  MYSQL 日期操作相關的函數 (date functions)\n NOW() 取得現在的日期時間 CURDATE() 取得現在的日期 CURTIME() 取得現在的時間 DATE() 取出日期時間中日期的部分 EXTRACT() 取出日期時間中特定的部分 DATE_ADD() 給日期時間增加指定的間隔 DATE_SUB() 給日期時間減去指定的間隔 DATEDIFF() 日期相減 TIMESTAMPDIFF() 日期時間相減 DATE_FORMAT() 格式化日期時間顯示  來源\n範例 SELECTDISTINCTSTRFTIME(\u0026#39;%Y-%m\u0026#39;,Date)ASdistinct_year_monthFROMtime_series;從time_series資料表裡面選取FROM time_series\nDATE欄位，並且只顯示年份還有月份STRFTIME('%Y-%m',Date)\n並且不顯示重複的值 DISTINCT\n別名為distinct_year_month AS distinct_year_month\n功能：得知在time_series資料表裡面年份還有月份\n結果：\n   distinct_year_month     2020-01   2020-02   2020-03   2020-04   2020-05   2020-06   2020-07    ．\n．\n．\n聚合函數 常見的聚合函數  AVG(column_name)：計算變數的平均數 COUNT(column_name)：計算變數的「非」遺漏值數 COUNT(*)：計算資料表的觀測值數 MAX(column_name)：計算變數的最大值 MIN(column_name)：計算變數的最小值 SUM(column_name)：計算變數的加總  GITHUB 詳細範例放在github，（之後補）\n","date":"2022-01-10T00:00:00Z","image":"https://yen0304.github.io/p/sql%E5%AD%B8%E7%BF%92%E7%AD%86%E8%A8%981-%E8%B3%87%E6%96%99%E6%9F%A5%E8%A9%A2%E7%8D%A8%E9%A1%AF%E4%B8%80%E5%80%BC%E9%81%8B%E7%AE%97%E7%AC%A6%E5%87%BD%E6%95%B8/logo_hue91c0a6a1fc261792a7714a8d89d8466_163197_120x120_fill_q75_box_smart1.jpeg","permalink":"https://yen0304.github.io/p/sql%E5%AD%B8%E7%BF%92%E7%AD%86%E8%A8%981-%E8%B3%87%E6%96%99%E6%9F%A5%E8%A9%A2%E7%8D%A8%E9%A1%AF%E4%B8%80%E5%80%BC%E9%81%8B%E7%AE%97%E7%AC%A6%E5%87%BD%E6%95%B8/","title":"SQL學習筆記(1)-資料查詢、獨顯一值、運算符、函數"},{"content":"SpringBoot電商平台實戰(2) 前言 本章承SpringBoot電商平台實戰(1)的專案，所以配置、工具等等都一樣。\n在實作商品有關的MVC時，其實沒有遇到什麼困難，畢竟東西熟悉了，也不用去用到session或是驗證等等，時間花最久的應該是在前端的javascript吧！因為本身沒有在做太多的研究，所以就依照兩年前學的也把它做完了，那些東西看了程式碼應該都知道，所以有興趣的可以至github下載，這章節就不做太多的介紹了。\n免跨域註解@CrossOrigin的另一個方法 之後看到網路上的連接，得知不用加上@CrossOrigin(origins = \u0026ldquo;*\u0026quot;)\n可以參考本連結，也是透過設置webconfiguration的方式\n程式碼：\n@Configuration public class CORSConfig { @Bean public WebMvcConfigurer corsConfigurer() { return new WebMvcConfigurerAdapter() { @Override public void addCorsMappings(CorsRegistry registry) { registry.addMapping(\u0026#34;/**\u0026#34;) .allowedHeaders(\u0026#34;*\u0026#34;) .allowedMethods(\u0026#34;*\u0026#34;) .allowedOrigins(\u0026#34;*\u0026#34;); } }; } } 所以maven中也可以省去了\n\u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;commons-codec\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;commons-codec\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.11\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 規劃資料庫中的商品數據 資料表創建相關數據：\nCREATETABLEt_product(idINTAUTO_INCREMENTPRIMARYKEY,categoryIdINT(20)DEFAULTNULLCOMMENT\u0026#39;商品分類id\u0026#39;,typeCHAR(100)DEFAULTNULLCOMMENT\u0026#39;商品類別\u0026#39;,titleCHAR(60)DEFAULTNULLCOMMENT\u0026#39;商品標題（名稱）\u0026#39;,priceINT(20)COMMENT\u0026#39;單價\u0026#39;,numINT(20)COMMENT\u0026#39;數量\u0026#39;,imagepathVARCHAR(100)COMMENT\u0026#39;圖片路徑\u0026#39;,priorityINT(10)DEFAULTNULLCOMMENT\u0026#39;顯示優先程度\u0026#39;,statusINT(1)DEFAULT1COMMENT\u0026#39;上架狀態1是0否\u0026#39;,created_userVARCHAR(20)COMMENT\u0026#39;創建人\u0026#39;,created_timeDATETIMECOMMENT\u0026#39;創建時間\u0026#39;,modified_userVARCHAR(20)COMMENT\u0026#39;最後修改人\u0026#39;,modified_timeDATETIMECOMMENT\u0026#39;最后修改時間\u0026#39;)Product Class 接下來創建Product這個類別，當然繼承了BaseEntity\n@Data public class Product extends BaseEntity implements Serializable { private Integer id; private Integer categoryId; private String type; private String title; private Integer price; private Integer num; private String imagepath; private Integer status; private Integer priority; } ProductRowMapper public class ProductRowMapper implements RowMapper\u0026lt;Product\u0026gt; { @Override public Product mapRow(ResultSet resultSet, int i) throws SQLException { Product product=new Product(); //後面result.getxx()，()裡面放的是要取得的資料在資料庫中的名字  product.setId(resultSet.getInt(\u0026#34;id\u0026#34;)); product.setCategoryId(resultSet.getInt(\u0026#34;categoryId\u0026#34;)); product.setType(resultSet.getString(\u0026#34;type\u0026#34;)); product.setTitle(resultSet.getString(\u0026#34;title\u0026#34;)); product.setPrice(resultSet.getInt(\u0026#34;price\u0026#34;)); product.setNum(resultSet.getInt(\u0026#34;num\u0026#34;)); product.setStatus(resultSet.getInt(\u0026#34;status\u0026#34;)); product.setPriority(resultSet.getInt(\u0026#34;priority\u0026#34;)); product.setCreated_user(resultSet.getString(\u0026#34;created_user\u0026#34;)); product.setCreated_time(resultSet.getDate(\u0026#34;created_time\u0026#34;)); product.setModified_user(resultSet.getString(\u0026#34;modified_user\u0026#34;)); product.setModified_time(resultSet.getDate(\u0026#34;modified_time\u0026#34;)); return product; } } 商品熱門查詢、商品詳情 這邊商品是用SQL新增的，因為其他新增商品的操作跟user的差不多，為了有效學習就省略了\nProduct-Dao Interface public interface ProductDao { //商品熱門排行  List\u0026lt;Product\u0026gt; findHostList(); //商品詳細數據  Product ReadById(Integer id); } Implement @Component public class ProductDaoImpl implements ProductDao{ @Autowired private NamedParameterJdbcTemplate namedParameterJdbcTemplate; @Override public List\u0026lt;Product\u0026gt; findHostList() { //https://www.fooish.com/sql/order-by.html DESC or ASC Sql語法排序  String sql=\u0026#34;SELECT * FROM t_product where status=1 order by priority desc limit 0,4\u0026#34;; Map\u0026lt;String,Object\u0026gt; map= new HashMap\u0026lt;\u0026gt;(); List\u0026lt;Product\u0026gt; list =namedParameterJdbcTemplate.query(sql,map,new ProductRowMapper()); if(list.size()\u0026gt;0){ return list; }else { //如果是空集合[]  return null; } } @Override public Product ReadById(Integer id) { String sql=\u0026#34;SELECT * FROM t_product where id=:Id\u0026#34;; Map\u0026lt;String,Object\u0026gt; map= new HashMap\u0026lt;\u0026gt;(); map.put(\u0026#34;Id\u0026#34;,id); List\u0026lt;Product\u0026gt; list =namedParameterJdbcTemplate.query(sql,map,new ProductRowMapper()); if(list.size()\u0026gt;0){ return list.get(0); }else { //如果是空集合[]  return null; } } } Product-Service Interface public interface ProductService { List\u0026lt;Product\u0026gt; getHostList(); //查詢商品詳細數據  Product ReadById(Integer id); } Implements 在實作Implement時，\n發現網路上的寫法是：\nprivate List\u0026lt;Product\u0026gt; findHostList() { return productDao.findHostList(); } private Product findById(Integer id){ return productDao.ReadById(id); } 把資料庫的servicem用成了private，應該是為了日後其他操作上要用，目前還不知道為什麼要用私有的方式實現。\n完整程式碼：\n@Component public class ProductServiceImpl implements ProductService{ @Autowired private ProductDao productDao; @Override public List\u0026lt;Product\u0026gt; getHostList() { List\u0026lt;Product\u0026gt; products = findHostList(); return products; } @Override public Product ReadById(Integer id) { Product product=findById(id); if(product == null){ throw new ProductNotFoundException(\u0026#34;找不到商品數據\u0026#34;); } return product; } private List\u0026lt;Product\u0026gt; findHostList() { return productDao.findHostList(); } private Product findById(Integer id){ return productDao.ReadById(id); } } Product-Controller @RestController @RequestMapping(\u0026#34;/products\u0026#34;) public class ProductController { @Autowired private ProductService productService; //  @GetMapping(\u0026#34;/list/hot\u0026#34;) public List\u0026lt;Product\u0026gt; getHostList(){ return productService.getHostList(); } @GetMapping public Product ReadById(@RequestParam Integer id){ return productService.ReadById(id); } } 部分Javascript 獲取商品資訊的Javascript function loading_product_data() { $.ajax({ url: producturl, dataType: \u0026#34;json\u0026#34;, success:function(data) { console.log(data); $(\u0026#34;#itemname\u0026#34;).text(data.title); $(\u0026#34;#price\u0026#34;).text(\u0026#34;$\u0026#34; + data.price); $(\u0026#34;#num\u0026#34;).text(\u0026#34;剩餘數量：\u0026#34; + data.num); pid=data.id; if(data.status == 0){ alert(\u0026#34;此商品已下架\u0026#34;); } } }); } 熱門排行Javascript unction showHotList() { $(\u0026#34;#hot-list\u0026#34;).empty(); $.ajax({ url: \u0026#34;/products/list/hot\u0026#34;, dataType: \u0026#34;json\u0026#34;, success:function(data) { hotlist=data; console.log(hotlist); for (var i = 0; i \u0026lt; hotlist.length; i++) { var html =\u0026#39;\u0026lt;div class=\u0026#34;content col-md-2\u0026#34;\u0026gt;\u0026#39; +\u0026#39;\u0026lt;div class=\u0026#34;title\u0026#34;\u0026gt;#{title}\u0026lt;/div\u0026gt;\u0026#39; +\u0026#39;\u0026lt;div class=\u0026#34;price\u0026#34;\u0026gt;$#{price}\u0026lt;/div\u0026gt;\u0026lt;a class=\u0026#34;d-flex justify-content-end\u0026#34; href=\u0026#34;#{href}\u0026#34;\u0026gt;查看商品\u0026lt;/a\u0026gt;\u0026#39; +\u0026#39;\u0026lt;/div\u0026gt;\u0026#39;; html = html.replace(/#{title}/g, hotlist[i].title); html = html.replace(/#{price}/g, hotlist[i].price); html = html.replace(/#{href}/g, \u0026#34;/product?id=\u0026#34; + hotlist[i].id); $(\u0026#34;#hot-list\u0026#34;).append(html); } } }); } 規劃本專案所有返回Model的Controller @org.springframework.stereotype.Controller public class Controller { @GetMapping(\u0026#34;/login\u0026#34;) public String loginpage(Model model) { return \u0026#34;login\u0026#34;; } //登入頁面  @GetMapping(\u0026#34;/login_success\u0026#34;) public String successpage(Model model) { return \u0026#34;/login_success\u0026#34;; } //首頁  @GetMapping(\u0026#34;/\u0026#34;) public String index(Model model) { return \u0026#34;/index\u0026#34;; } //註冊頁面  @GetMapping(\u0026#34;/register\u0026#34;) public String register(Model model){ return \u0026#34;/register\u0026#34;;} //user修改資料頁面  @GetMapping(\u0026#34;/users/@{username}\u0026#34;) public String usermodified(Model model){ return \u0026#34;/user_modified\u0026#34;;} //商品詳情頁面  @GetMapping(\u0026#34;/product\u0026#34;) public String products(Model model){ return \u0026#34;/product\u0026#34;;} //購物車詳情頁面  @GetMapping(\u0026#34;/mycarts\u0026#34;) public String mycarts(Model model){ return \u0026#34;/mycarts\u0026#34;;} } 其他頁面HTML、ＣＳＳ、ＪＳ以及狀態程式碼、class資料夾位置都放在github裡面。需要的大家可以去看看。\nGithub https://github.com/yen0304/Electronic-business-platform\n","date":"2022-01-09T00:00:00Z","image":"https://yen0304.github.io/p/springboot%E9%9B%BB%E5%95%86%E5%B9%B3%E5%8F%B0%E5%AF%A6%E6%88%B02%E5%95%86%E5%93%81%E8%A9%B3%E6%83%85%E7%86%B1%E9%96%80%E5%95%86%E5%93%81%E6%8E%92%E5%BA%8F/logo_hu807666e0efc0d1033f1aa166a1ba5367_206258_120x120_fill_q75_box_smart1.jpeg","permalink":"https://yen0304.github.io/p/springboot%E9%9B%BB%E5%95%86%E5%B9%B3%E5%8F%B0%E5%AF%A6%E6%88%B02%E5%95%86%E5%93%81%E8%A9%B3%E6%83%85%E7%86%B1%E9%96%80%E5%95%86%E5%93%81%E6%8E%92%E5%BA%8F/","title":"SpringBoot電商平台實戰(2)，商品詳情、熱門商品排序"},{"content":"SpringBoot電商平台實戰(1) 前言 在練習的差不多之後，決定實作一個完整的電商平台「SpringBoot電商平台實戰」，也參考了不少網路上的資源，主要是參考CSDN上的雨醉東風（由於不知能不能引用所以有興趣可以自行查詢）來撰寫api，參考架構，差別最大的是該教學是使用MyBatis做資料庫操作，而我是使用JDBC，預計將來會再嘗試Redis、SpringSecurity、再加上前端完成一個完整的網站。\n本來在2021年的10月初已經做好了，但遇到需要實作記住持續登入的功能，雖然SpringSecurity做得到，但部分功能都涉及到session，還有登入時候的POST方法驗證登入，變成了SpringSecurity + 自己做的POST一起登入的問題，還有持續保持登入狀態等問題，將來會再更熟悉SpringSecurity再把他做整合。\n本例相關工具、環境、語言、配置 開發環境：\n Java 11 IntelliJ IDEA 2020.3.2 Spring Boot 2.3.7 RELEASE  工具：\nLombok（使用教學）用途：提高開發效率，自動產生getter以及setter等等。\n資料庫：MySql 8.0.22\n操作資料庫方法：JDBC\n前端模板引擎：Freemarker\n其他：\n前端：html、css、javascript、jquery、ajax\n學習到的新知識：\n密碼加密、統一異常處例、AOP、MVC、Spring Session\n如果以上有東西不熟悉的話，可以參考本網站個文章來做參考。\napplication.properties配置 #DB Configuration spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver spring.datasource.url=jdbc:mysql://localhost:3306/db_store?serverTimezone=Asia/Taipei\u0026amp;characterEncoding=utf-8 spring.datasource.username=root spring.datasource.password=springboot #Spring Session ## Session 存儲方式 spring.session.store-type=redis ## Session 過期時間，默認單位為 s server.servlet.session.timeout=600 ## Session 存儲到 Redis 鍵的前綴 spring.session.redis.namespace=test:spring:session #Freemaker設定 spring.freemarker.cache=false # 模版後綴名 默認為ftl spring.freemarker.suffix=.ftl # 文件編碼 spring.freemarker.charset=UTF-8 # 模版加載的目錄 spring.freemarker.template-loader-path=classpath:/templates/ # 靜態資源訪問路徑 spring.mvc.static-path-pattern=/static/** # 獲取根目錄路徑 spring.freemarker.request-context-attribute=request maven設定 本例子先使用了Lombok、jdbc、mysql、跨域註解的commons-codec、Freemarker\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;project xmlns=\u0026#34;http://maven.apache.org/POM/4.0.0\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xsi:schemaLocation=\u0026#34;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\u0026#34;\u0026gt; \u0026lt;modelVersion\u0026gt;4.0.0\u0026lt;/modelVersion\u0026gt; \u0026lt;parent\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-parent\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.3.7.RELEASE\u0026lt;/version\u0026gt; \u0026lt;relativePath/\u0026gt; \u0026lt;!-- lookup parent from repository --\u0026gt; \u0026lt;/parent\u0026gt; \u0026lt;groupId\u0026gt;com.example\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;demo\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;0.0.1-SNAPSHOT\u0026lt;/version\u0026gt; \u0026lt;name\u0026gt;demo\u0026lt;/name\u0026gt; \u0026lt;description\u0026gt;Demo project for Spring Boot\u0026lt;/description\u0026gt; \u0026lt;properties\u0026gt; \u0026lt;java.version\u0026gt;11\u0026lt;/java.version\u0026gt; \u0026lt;/properties\u0026gt; \u0026lt;dependencies\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-web\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-data-redis\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.session\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-session-data-redis\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.projectlombok\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;lombok\u0026lt;/artifactId\u0026gt; \u0026lt;optional\u0026gt;true\u0026lt;/optional\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-freemarker\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-jdbc\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;commons-codec\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;commons-codec\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.11\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- https://mvnrepository.com/artifact/mysql/mysql-connector-java --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;mysql\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;mysql-connector-java\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;8.0.22\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-test\u0026lt;/artifactId\u0026gt; \u0026lt;scope\u0026gt;test\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; \u0026lt;build\u0026gt; \u0026lt;plugins\u0026gt; \u0026lt;plugin\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-maven-plugin\u0026lt;/artifactId\u0026gt; \u0026lt;configuration\u0026gt; \u0026lt;excludes\u0026gt; \u0026lt;exclude\u0026gt; \u0026lt;groupId\u0026gt;org.projectlombok\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;lombok\u0026lt;/artifactId\u0026gt; \u0026lt;/exclude\u0026gt; \u0026lt;/excludes\u0026gt; \u0026lt;/configuration\u0026gt; \u0026lt;/plugin\u0026gt; \u0026lt;/plugins\u0026gt; \u0026lt;/build\u0026gt; \u0026lt;/project\u0026gt; 規劃資料庫中的用戶數據 首先，先創一個名為db_store的資料庫\nCREATEDATABASEdb_storeUSEdb_store再來資料表創建相關數據，這邊學到了一個東西，就是鹽值，是將原密碼透過某種加密方式而產生的新密碼名稱，詳細介紹下面會解釋。\nCREATETABLEt_user(uidINTAUTO_INCREMENTPRIMARYKEY,usernameVARCHAR(20)UNIQUENOTNULL,passwordCHAR(32)NOTNULL,saltCHAR(60)COMMENT\u0026#39;鹽值\u0026#39;,genderINT(1)COMMENT\u0026#39;性别:0-女,1-男\u0026#39;,phoneVARCHAR(20),emailVARCHAR(50),avatarVARCHAR(100)COMMENT\u0026#39;頭像\u0026#39;,is_deleteINT(1)COMMENT\u0026#39;是否删除:0-否,1-是\u0026#39;,created_userVARCHAR(20)COMMENT\u0026#39;創建人\u0026#39;,created_timeDATETIMECOMMENT\u0026#39;創建時間\u0026#39;,modified_userVARCHAR(20)COMMENT\u0026#39;最後修改人\u0026#39;,modified_timeDATETIMECOMMENT\u0026#39;最後修改時間\u0026#39;,)創建用戶的實體類別 基類（Entity） 在這邊，要先創建所有類別的基類，意思就是在將來所有實體的類別，例如商品、用戶等等都會用到這個基類，那這個類別我們把它命名為BaseEntity，詳細功能在本例中就是會記錄上最後修改的時間、使用者等等，大家應該看例子就知道了\n在這邊也學到了序列化，簡單說就是在電腦上，我們可以把資料順利的儲存在Ram上面，以便在執行上更順利，詳細的解說我也不太清楚，總之就是（以下網路參考）\n1、當想把的內存中的對象狀態保存到一個文件中或者資料庫中時候；\n2、當想用套接字在網絡上傳送對象的時候；\n3、當想通過RMI傳輸對象的時候；\n用上Serializable就對了！\n/*全部實體類別的基底類別*/ //implements Serializable序列化 @Data public class BaseEntity implements Serializable { private String created_user ; private Date created_time; private String modified_user; private Date modified_time; } User Class 接下來創建User 這個類別，當然繼承了BaseEntity\n@Data public class User extends BaseEntity implements Serializable { private Integer uid; private String username; private String password; private String updatepassword; private Integer gender; private String phone; private String email; private String avatar; private Integer isDelete; private String role; private Integer enabled; } UserRowMapper public class UserRowMapper implements RowMapper\u0026lt;User\u0026gt; { @Override public User mapRow(ResultSet resultSet, int i) throws SQLException { User user=new User(); //後面result.getxx()，()裡面放的是要取得的資料在資料庫中的名字  user.setUid(resultSet.getInt(\u0026#34;uid\u0026#34;)); user.setUsername(resultSet.getString(\u0026#34;username\u0026#34;)); user.setPassword(resultSet.getString(\u0026#34;password\u0026#34;)); user.setSalt(resultSet.getString(\u0026#34;Salt\u0026#34;)); user.setGender(resultSet.getInt(\u0026#34;gender\u0026#34;)); user.setPhone(resultSet.getString(\u0026#34;phone\u0026#34;)); user.setEmail(resultSet.getString(\u0026#34;email\u0026#34;)); user.setAvatar(resultSet.getString(\u0026#34;avatar\u0026#34;)); user.setIsDelete(resultSet.getInt(\u0026#34;is_delete\u0026#34;)); user.setCreated_user(resultSet.getString(\u0026#34;created_user\u0026#34;)); user.setCreated_time(resultSet.getTime(\u0026#34;created_time\u0026#34;)); user.setModified_user(resultSet.getString(\u0026#34;modified_user\u0026#34;)); user.setModified_time(resultSet.getTime(\u0026#34;modified_time\u0026#34;)); return user; } } 創建用戶、用戶登入、修改數據、查詢數據 User-Dao Interface public interface UserDao { //創建用戶  String CreateUser(User user); //根據用戶名稱username查詢數據  List\u0026lt;User\u0026gt; ReadByUsername(String username); //根據用戶uid查詢數據  List\u0026lt;User\u0026gt; ReadByUid(Integer uid); //根據用戶uid修改數據  String UpdateByUid(Integer uid,User user); } Implement @Component public class UserImpl implements UserDao{ @Autowired private NamedParameterJdbcTemplate namedParameterJdbcTemplate; @Override public String CreateUser(User user) { String sql =\u0026#34;INSERT INTO t_user\u0026#34; + \u0026#34;(username,password,salt,gender,phone,email,avatar,is_delete,created_user,created_time,modified_user,modified_time)\u0026#34; + \u0026#34;VALUE\u0026#34; + \u0026#34;(:userName,:userPassword,:Salt,:Gender,:Phone,:Email,:Avatar,:Is_delete,:Create_user,:Create_time,:Modified_user,:Modified_time)\u0026#34;; Map\u0026lt;String, Object\u0026gt; map =new HashMap\u0026lt;\u0026gt;(); map.put(\u0026#34;userName\u0026#34;,user.getUsername()); map.put(\u0026#34;userPassword\u0026#34;,user.getPassword()); map.put(\u0026#34;Salt\u0026#34;,user.getSalt()); map.put(\u0026#34;Gender\u0026#34;,user.getGender()); map.put(\u0026#34;Phone\u0026#34;,user.getPhone()); map.put(\u0026#34;Email\u0026#34;,user.getEmail()); map.put(\u0026#34;Avatar\u0026#34;,user.getAvatar()); map.put(\u0026#34;Is_delete\u0026#34;,user.getIsDelete()); map.put(\u0026#34;Create_user\u0026#34;,user.getCreated_user()); map.put(\u0026#34;Create_time\u0026#34;,user.getCreated_time()); map.put(\u0026#34;Modified_user\u0026#34;,user.getModified_user()); map.put(\u0026#34;Modified_time\u0026#34;,user.getModified_time()); namedParameterJdbcTemplate.update(sql,map); return (\u0026#34;註冊成功\u0026#34;); } @Override public List\u0026lt;User\u0026gt; ReadByUsername(String username) { String sql=\u0026#34;SELECT * FROM t_user WHERE username=:userName\u0026#34;; Map\u0026lt;String,Object\u0026gt;map= new HashMap\u0026lt;\u0026gt;(); map.put(\u0026#34;userName\u0026#34;,username); List\u0026lt;User\u0026gt; list =namedParameterJdbcTemplate.query(sql,map,new UserRowMapper()); if(list.size()\u0026gt;0){ return list; }else { //如果是空集合[]  return null; } } @Override public List\u0026lt;User\u0026gt; ReadByUid(Integer uid) { String sql=\u0026#34;SELECT * FROM t_user WHERE uid=:Uid\u0026#34;; Map\u0026lt;String,Object\u0026gt;map= new HashMap\u0026lt;\u0026gt;(); map.put(\u0026#34;Uid\u0026#34;,uid); List\u0026lt;User\u0026gt; list =namedParameterJdbcTemplate.query(sql,map,new UserRowMapper()); if(list.size()\u0026gt;0){ return list; }else { //如果是空集合[]  return null; } } @Override public String UpdateByUid(Integer uid, User user) { String sql =\u0026#34;UPDATE t_user SET \u0026#34; + \u0026#34;phone=:Phone,email=:Email,gender=:Gender ,modified_user=:Modified_user,modified_time=:Modified_time\u0026#34; + \u0026#34; WHERE uid=:Uid\u0026#34;; Map\u0026lt;String, Object\u0026gt; map =new HashMap\u0026lt;\u0026gt;(); map.put(\u0026#34;Gender\u0026#34;,user.getGender()); map.put(\u0026#34;Phone\u0026#34;,user.getPhone()); map.put(\u0026#34;Email\u0026#34;,user.getEmail()); map.put(\u0026#34;Modified_user\u0026#34;,user.getModified_user()); map.put(\u0026#34;Modified_time\u0026#34;,user.getModified_time()); map.put(\u0026#34;Uid\u0026#34;,uid); namedParameterJdbcTemplate.update(sql,map); return \u0026#34;修改成功\u0026#34;; } } User-Service 這邊學到了一個程式上設計的知識，就是在做創建用戶的service層時，也會順便做ReadByUsername(String username)這個依據用戶名稱查詢資料的方法，目的就是實作我們實際上要避免用戶名稱重複，或是做修改資料的時候找不到帳戶等等的概念。\nInterface public interface UserService { //創建用戶  String CreateUser(User user); //根據用戶名稱username查詢數據  List\u0026lt;User\u0026gt; ReadByUsername(String username); //登入  List\u0026lt;User\u0026gt; login(String username,String password); //修改  String UpdateByUid(Integer uid,User user); } Implements 這邊學到了一個密碼加密的方法，就是先在後端產生一串隨機的亂碼，就是鹽值（Salt），之後再經過自定義的方法，把使用者的密碼做計算之後在產生一組新的密碼，\n簡單來說：\n即使別人擁有了鹽值過後，他也沒辦法得知我們在後端驗證演算的方式，我們可以是加上一組固定的數字，加減乘除等等都可以，鹽值經過這些計算之後再到資料庫已儲存的加密結果做驗證。\n所以我們來實作這些功能部分需要的工具\n鹽值的產生 //https://www.jianshu.com/p/2c62ae005db4 參考網址 public class UUIDutil { public static String uuid(){ return UUID.randomUUID().toString().replace(\u0026#34;-\u0026#34;,\u0026#34;\u0026#34;); } } MD5加密 這邊直接把鹽值再加上使用者輸入的原始密碼加上之後，在做MD5加密產生在資料庫儲存的密碼\n@Component public class MD5util { public static String md5(String src ,String salt){ //這邊使用了springframework的加密方式  //md5DigestAsHex參數是Bytes，所以透過java String類將字串轉為Bytes  String result=src+ salt; return DigestUtils.md5DigestAsHex(result.getBytes()); } } 完整程式碼 @Component public class UserServiceImpl implements UserService{ @Autowired private UserDao userDao; @Autowired private RedisTemplate redisTemplate; @Override public String CreateUser(User user) { //先檢查是否有重複名稱  String username =user.getUsername(); //如果查詢結果不為null，代表有重複名稱  if(userDao.ReadByUsername(username) != null){ // 拋出錯誤  throw new IllegalArgumentException(\u0026#34;用戶名稱重複\u0026#34;); } //如果可以執行到這一行，代表用戶名稱沒有被使用  //存取當下時間  Date now =new Date(); //密碼加密  String salt = UUIDutil.uuid(); user.setSalt(salt); String md5Password = MD5util.md5(user.getPassword(),salt); user.setPassword(md5Password); //開始設置其他後台參數，時間，使用者等等  user.setIsDelete(0); user.setCreated_user(username); user.setCreated_time(now); user.setModified_user(username); user.setModified_time(now); return userDao.CreateUser(user); } @Override public List\u0026lt;User\u0026gt; login(String username, String password) { //新增陣列，來接受userDao.ReadByUsername的回傳資料  List\u0026lt;User\u0026gt; list=new ArrayList\u0026lt;\u0026gt;(); list=userDao.ReadByUsername(username); //因為只會有一筆，所以在陣列的第0個位置  User user= list.get(0); if(userDao.ReadByUsername(username)== null){ // 拋出錯誤  throw new IllegalArgumentException(\u0026#34;登入失敗，找不到帳號\u0026#34;); } if(user.getIsDelete()==1){ throw new IllegalArgumentException(\u0026#34;登入失敗，帳號已經被刪除\u0026#34;); } String salt = user.getSalt(); String md5Password = MD5util.md5(password,salt); if(!user.getPassword().equals(md5Password)){ throw new PasswordExpiredException(\u0026#34;密碼輸入錯誤，請重新輸入\u0026#34;); } return list; } @Override public List\u0026lt;User\u0026gt; ReadByUsername(String username) { return userDao.ReadByUsername(username); } @Override public String UpdateByUid(Integer uid, User user) { if(userDao.ReadByUid(uid)== null){ // 拋出錯誤  throw new IllegalArgumentException(\u0026#34;獲取數據失敗，請再重新嘗試一次\u0026#34;); } //新增陣列，來接受userDao.ReadByUsername的回傳資料  List\u0026lt;User\u0026gt; list=new ArrayList\u0026lt;\u0026gt;(); list=userDao.ReadByUid(uid); //因為只會有一筆，所以在陣列的第0個位置  User olduser= list.get(0); if(olduser.getIsDelete()==1){ throw new IllegalArgumentException(\u0026#34;登入失敗，帳號已經被刪除\u0026#34;); } olduser.setEmail(user.getEmail()); olduser.setPhone(user.getPhone()); olduser.setGender(user.getGender()); olduser.setModified_time(new Date()); olduser.setModified_user(user.getModified_user()); return userDao.UpdateByUid(uid,olduser); } } 如何維持登入資訊 在這邊我卡了很久，因為記住登入的方法雖然Spring Security中有這個功能，但是在獲取資料上還沒有學習到，因為USER Controller也需要獲取這些記住的資訊，但也因為在整合上還沒有觸碰到（因為已經做了差不多了），所以打算以後先單獨學習再來做整合，才不會遇到連Service層都需要重做的問題，所以就去了解了Cookie、Session、Token（這邊卡超久去理解QAQ）。\nCookie、Session、Token是什麼？ 參考網址 在看完文章以及一些實作的影片之後，也特別推薦這部Youtube的影片，這次決定用Session，也把目前得知的知識記錄下來，\nCookie：儲存在瀏覽器裡面，裡面存著cookie的名字、cookie值（也因為這樣Cookie 只支持存字符串數據）、在哪一個domain、安全性等等\u0026hellip;（上面影片有詳細說明），藉由request header傳遞，藉由設定過期時間來使瀏覽器記住Cookie，這樣關閉瀏覽器在開啟之後就還是會存在在瀏覽器中。\nSession：session 是另一種記錄服務器和客戶端會話狀態的機制，其實Session是跟Cookie一樣的東西，只是它儲存在伺服器當中，透過(Key,Value)儲存在伺服器當中，使用者透過儲存在Cookie中的SessionId傳送到伺服器獲取資訊。\nSessionId：他其實就是儲存在Cookie中的Cookie Name叫SessionId的Value，裡面記錄一組SessionId。\nSessionId的產生(參考)，是由伺服器所產生的，再一次對話中都會產生，在Java裡面就是使用\nHttpServletRequest.getSession(ture)這邊相等於HttpServletRequest.getSession()，因為預設是true，這邊的意思就是如果沒有得到SessionID的時候伺服器就會自動產生了。\n所以簡單說，使用者的瀏覽器Cookie儲存著一組SessionID（號碼牌），之後使用者再藉由Cookie傳送到伺服器裡面，伺服器就會藉由SessionID，來在伺服器中藉由ke來獲取 value\nToken：更複雜，但是更安全，Spring Security就是用這種方式來實現remember me的機制，日後再來更新。\n \n透過實做攔截器來維持登入 我們就透過攔截器，來攔截HttpServletRequest中的Session，裡面存放用戶的uid，如果為空，返回302狀態碼，另外也學習到了如何使用HttpServletRequest request以及HttpServletResponse response，本來在想說是不是要新增類別把之後，用變數接住在透過return回傳回去，結果測試了一下根本不用，直接在方法裡面操作request以及response就好。\n新增類別：\n@Component public class LoginInterceptor implements HandlerInterceptor { @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception { if (request.getSession().getAttribute(\u0026#34;uid\u0026#34;) == null) { System.out.println(\u0026#34;session中的uid為null\u0026#34;); response.setStatus(302); return false; } //System.out.println(\u0026#34;session中的uid為= \u0026#34; + request.getSession().getAttribute(\u0026#34;uid\u0026#34;));  return true; } } 透過@Configuration來設定\n@Configuration public class WebConfig implements WebMvcConfigurer { @Autowired private LoginInterceptor loginInterceptor; @Override public void addInterceptors(InterceptorRegistry registry) { /* //在這個patterns裡面就是不用登入的 List\u0026lt;String\u0026gt; patterns = new ArrayList\u0026lt;\u0026gt;(); patterns.add(\u0026#34;/user_login\u0026#34;); patterns.add(\u0026#34;/static/**\u0026#34;); */ //有些之後會用到  registry.addInterceptor(loginInterceptor) .addPathPatterns(\u0026#34;/login_success\u0026#34;) .addPathPatterns(\u0026#34;/carts/**\u0026#34;) .addPathPatterns(\u0026#34;/users/**\u0026#34;); //.excludePathPatterns(patterns);  } } 這樣之後只要call 跟/user/**有關的API，就會先被攔截器攔截起來，經過驗證有無獲取user Id之後，才能進行相關操作，甚至在Controller裡面也可以再接住session一次，就可以在Service中跟User.getId()來進一步驗證id是否相同。\nUser-Controller 這邊會加上@CrossOrigin(origins = \u0026ldquo;*\u0026quot;)的原因目前還不清楚，只是這個是跨網域專用的，因為沒有加上去時候雖然APITester沒問題，但透過Ajax call API的時候，ajax 會得不到物件的資料，得到的數據是\u0026rdquo;{\u0026lsquo;readyState\u0026rsquo;:0,\u0026lsquo;status\u0026rsquo;:0,\u0026lsquo;statusText\u0026rsquo;:\u0026lsquo;error\u0026rsquo;}\u0026quot;，查了很久才發現加上這個就好了。\n@RestController @CrossOrigin(origins = \u0026#34;*\u0026#34;) public class UserController { @Autowired private UserService userService; //用戶註冊  @PostMapping(\u0026#34;/register\u0026#34;) public String create(@RequestBody User user){ return userService.CreateUser(user); } //用戶登入  @PostMapping(\u0026#34;/userlogin\u0026#34;) public List\u0026lt;User\u0026gt; userlogin(HttpSession session, @RequestBody User user){ List\u0026lt;User\u0026gt; list =new ArrayList\u0026lt;\u0026gt;(); list =userService.login(user.getUsername(),user.getPassword()); //登入成功後設置session的值  session.setAttribute(\u0026#34;uid\u0026#34;,list.get(0).getUid()); session.setAttribute(\u0026#34;username\u0026#34;,list.get(0).getUsername()); return (list); } @PutMapping(\u0026#34;users/{uid}\u0026#34;) //根據帳號做修改  public String update(@PathVariable Integer uid,@RequestBody User user){ //@Path用來取得url路徑的值  return userService.UpdateByUid(uid,user); } @GetMapping(\u0026#34;users/{username}\u0026#34;) public List\u0026lt;User\u0026gt; read(@PathVariable String username){ //@Path用來取得url路徑的值  return userService.ReadByUsername(username); } //用來獲取session中的username，在前端某些需要的地方會用到。  @GetMapping(\u0026#34;users/session-username\u0026#34;) public String getsessionusername(HttpSession session){ //@Path用來取得url路徑的值  return (String)session.getAttribute(\u0026#34;username\u0026#34;); } //用戶登出  @GetMapping(\u0026#34;/sign_out\u0026#34;) public String signout(HttpSession session){ //銷毀session中的KV  session.removeAttribute(\u0026#34;uid\u0026#34;); session.removeAttribute(\u0026#34;username\u0026#34;); return \u0026#34;登出成功\u0026#34;; } } 規劃前端Javascript 登入頁面的Javascript var apiurl={ loginurl:\u0026#34;/userlogin\u0026#34;, successloginurl:\u0026#34;/\u0026#34; } $(\u0026#34;#enter\u0026#34;).click(function () { var username = $(\u0026#34;#username\u0026#34;).val(); var password = $(\u0026#34;#password\u0026#34;).val(); $.post({ url:apiurl.loginurl, contentType:\u0026#34;application/json;charset=UTF-8\u0026#34;, data:JSON.stringify({\u0026#34;username\u0026#34;:username,\u0026#34;password\u0026#34;:password}), success:function(res) { //console.log(res);  window.location.href = apiurl.successloginurl;//正確登入後頁面跳轉回首頁  } }); }); 註冊頁面Javascript var apiurl={ registerurl:\u0026#34;/register\u0026#34;, registersuccess:\u0026#34;/\u0026#34; } $(\u0026#34;#sub\u0026#34;).click(function () { var username = $(\u0026#34;#username\u0026#34;).val(); var password = $(\u0026#34;#password\u0026#34;).val(); var phone = $(\u0026#34;#phone\u0026#34;).val(); var email = $(\u0026#34;#email\u0026#34;).val(); var gender = 0; gender=$(\u0026#34;input[name=\u0026#39;gender\u0026#39;]:checked\u0026#34;).val(); $.post({ url:apiurl.registerurl, contentType:\u0026#34;application/json;charset=UTF-8\u0026#34;, data:JSON.stringify({\u0026#34;username\u0026#34;:username,\u0026#34;password\u0026#34;:password,\u0026#34;gender\u0026#34;:gender,\u0026#34;phone\u0026#34;:phone,\u0026#34;email\u0026#34;:email}), success:function(res) { alert(\u0026#34;註冊成功\u0026#34;); window.location.href = apiurl.registersuccess;//正確登入後頁面跳轉  } }); }); 最重要的Javascript碼，前端得知使否登入 主要透過Checklogin();檢查是否登入來決定html的狀況，例如是登入按鈕還是登出按鈕，\n在別的頁面，例如加入購物車時、前往個人商品頁時，都可以先透過/users/session-username這個API，如果進去的話就會反回username，沒有登入的話就會被攔截器返回302 error。\n//載入頁面時先在入熱門商品資訊（之後文章會寫） //再來進入Checklogin();檢查是否登入來決定html的狀況，例如是登入按鈕還是登出按鈕 $(document).ready(function(){ showHotList(); Checklogin(); }); function showHotList() { $(\u0026#34;#hot-list\u0026#34;).empty(); $.ajax({ url: \u0026#34;/products/list/hot\u0026#34;, dataType: \u0026#34;json\u0026#34;, success:function(data) { hotlist=data; console.log(hotlist); for (var i = 0; i \u0026lt; hotlist.length; i++) { var html =\u0026#39;\u0026lt;div class=\u0026#34;content col-md-2\u0026#34;\u0026gt;\u0026#39; +\u0026#39;\u0026lt;div class=\u0026#34;title\u0026#34;\u0026gt;#{title}\u0026lt;/div\u0026gt;\u0026#39; +\u0026#39;\u0026lt;div class=\u0026#34;price\u0026#34;\u0026gt;$#{price}\u0026lt;/div\u0026gt;\u0026lt;a class=\u0026#34;d-flex justify-content-end\u0026#34; href=\u0026#34;#{href}\u0026#34;\u0026gt;查看商品\u0026lt;/a\u0026gt;\u0026#39; +\u0026#39;\u0026lt;/div\u0026gt;\u0026#39;; html = html.replace(/#{title}/g, hotlist[i].title); html = html.replace(/#{price}/g, hotlist[i].price); html = html.replace(/#{href}/g, \u0026#34;/product?id=\u0026#34; + hotlist[i].id); $(\u0026#34;#hot-list\u0026#34;).append(html); } } }); } var username=\u0026#34; \u0026#34;; function Checklogin() { $.ajax({ url: \u0026#34;/users/session-username\u0026#34;, dataType: \u0026#34;text\u0026#34;, success:function(data) { console.log(data); var html; html=\u0026#39;\u0026lt;label\u0026gt;#{username}\u0026lt;/label\u0026gt;\u0026lt;a href=\u0026#34;/sign_out\u0026#34;\u0026gt;登出\u0026lt;/a\u0026gt;\u0026#39;; html = html.replace(/#{username}/g, data); $(\u0026#34;#check\u0026#34;).append(html); username=data; },error:function (){ //alert(\u0026#34;沒登入\u0026#34;);  } }); } //在頁面Checklogin()時，會依據有無登入來設定js變數username的值，如果沒有設置到的話代表沒有登入， //所以按下修改資料的超連結按鈕時，就會進行阻擋反饋 $(document).on(\u0026#34;click\u0026#34;,\u0026#39;#modified\u0026#39;,function(){ if(username == \u0026#34; \u0026#34;){ alert(\u0026#34;尚未登入\u0026#34;); }else{ window.location.href =\u0026#34;/users/@\u0026#34;+ username; } }); @ControllerAdvice統一處理異常 springboot提供了可以用來攔截並處理應用程式中全部Controller所拋出的Exception例外錯誤的註解@ControllerAdvice，由於用法很固定，所以也不多說明，但目前沒有很摸懂各種錯誤詳細的錯誤碼是多少，目前也只把種類（2-5)開頭用正確而已\n@ControllerAdvice public class MyExceptionHandler { @ExceptionHandler(IllegalArgumentException.class) public ResponseEntity\u0026lt;String\u0026gt; handle(IllegalArgumentException exception) { return ResponseEntity.status(HttpStatus.SERVICE_UNAVAILABLE) .body(\u0026#34;IllegalArgumentException：\u0026#34; + exception.getMessage()); } } 規劃本專案所有返回Model的Controller @org.springframework.stereotype.Controller public class Controller { @GetMapping(\u0026#34;/login\u0026#34;) public String loginpage(Model model) { return \u0026#34;login\u0026#34;; } //登入頁面  @GetMapping(\u0026#34;/login_success\u0026#34;) public String successpage(Model model) { return \u0026#34;/login_success\u0026#34;; } //首頁  @GetMapping(\u0026#34;/\u0026#34;) public String index(Model model) { return \u0026#34;/index\u0026#34;; } //註冊頁面  @GetMapping(\u0026#34;/register\u0026#34;) public String register(Model model){ return \u0026#34;/register\u0026#34;;} //user修改資料頁面  @GetMapping(\u0026#34;/users/@{username}\u0026#34;) public String usermodified(Model model){ return \u0026#34;/user_modified\u0026#34;;} //商品詳情頁面  @GetMapping(\u0026#34;/product\u0026#34;) public String products(Model model){ return \u0026#34;/product\u0026#34;;} //購物車詳情頁面  @GetMapping(\u0026#34;/mycarts\u0026#34;) public String mycarts(Model model){ return \u0026#34;/mycarts\u0026#34;;} } 其他頁面HTML、ＣＳＳ、ＪＳ以及狀態程式碼、class資料夾位置都放在github裡面。需要的大家可以去看看。\nGithub https://github.com/yen0304/Electronic-business-platform\n","date":"2022-01-08T00:00:00Z","image":"https://yen0304.github.io/p/springboot%E9%9B%BB%E5%95%86%E5%B9%B3%E5%8F%B0%E5%AF%A6%E6%88%B01%E7%94%A8%E6%88%B6%E8%A8%BB%E5%86%8A%E7%94%A8%E6%88%B6%E7%99%BB%E5%85%A5%E4%BF%AE%E6%94%B9%E8%B3%87%E6%96%99/logo_hu807666e0efc0d1033f1aa166a1ba5367_206258_120x120_fill_q75_box_smart1.jpeg","permalink":"https://yen0304.github.io/p/springboot%E9%9B%BB%E5%95%86%E5%B9%B3%E5%8F%B0%E5%AF%A6%E6%88%B01%E7%94%A8%E6%88%B6%E8%A8%BB%E5%86%8A%E7%94%A8%E6%88%B6%E7%99%BB%E5%85%A5%E4%BF%AE%E6%94%B9%E8%B3%87%E6%96%99/","title":"SpringBoot電商平台實戰(1)，用戶註冊、用戶登入、修改資料"},{"content":"Freemarker + Spring Security 整合 由於方便往後的實戰學習，在學會了快速的在Spring Boot 使用Freemarker在localhost:8080上執行之後，也學會了用Spring Security 控制訪問權限，在整合他們途中，其實遇到了不少配置上的問題，但也成功解決了，所以決定記錄這些解決問題的過程，也更了解了Spring Security的認證寫法。\npom.xml maven配置 Spring Security （先不要加上spring Security，因為加上去了所有為配置的默認都會受到全縣控管）\n\u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-security\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; Freemarker \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-freemarker\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; Application.properties配置 Freemaker設定 #Freemaker設定spring.freemarker.cache=false# 模版後綴名 默認為ftlspring.freemarker.suffix=.ftl# 文件編碼spring.freemarker.charset=UTF-8# 模版加載的目錄spring.freemarker.template-loader-path=classpath:/templates/# 靜態資源訪問路徑spring.mvc.static-path-pattern=/static/**# 獲取根目錄路徑spring.freemarker.request-context-attribute=request開始撰寫程式部分 這部分的先後順序很重要，因為如果Freemarker其中有錯誤，css或js會跑不出來，也同樣的Spring Security如果有錯誤，css或js也會因爲訪問權限而跑不出來，所以在撰寫時順序如下\n撰寫順序  確認Freemarker配置成功，包含get請求，以及靜態資源css js訪問成功 使用Spring Security下，得知靜態支援有受到保護，並請把保護關閉。 使用Spring security測試相關功能。  Freemaker靜態配置至測試成功 檔案存放位置 檔案存放位置很重要，也跟application.properties很相關，包含了靜態資源的訪問路徑，\n這次規劃了user_login.ftl、login.css、login.js為登入Spring Security角色頁面\n，login_success、login_success.css為登入成功登入之後跳轉的頁面\n ftl、css、js檔案存放配置 \nFtl(html)存取css、js之重點 在login_success下，存取css、js的html語法為下\n\u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;/static/css/login.css\u0026#34;\u0026gt; \u0026lt;script src=\u0026#34;/static/js/login.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; 重點就是因為我們已經配置好了路徑，所以會因Freemarker會有不同的寫法\nController層 應該沒什麼好解釋的\n@Controller public class Controller { @GetMapping(\u0026#34;/user_login\u0026#34;) public String loginpage(Model model) { return \u0026#34;/user_login\u0026#34;; } @GetMapping(\u0026#34;/login_success\u0026#34;) public String successpage(Model model) { return \u0026#34;/login_success\u0026#34;; } } 如何判斷測試成功 運行SpringBoot之後，以下圖解是我們看到的畫面，使用瀏覽器是chrome\n 運行畫面 \n這時候大致上會有兩種情況就是Http Status 404跟200，404就代表是url路徑錯了，這時候就要去檢查Controller層的url是不是有寫錯，200的話就是測試成功。\nSpring Security部分 檢查靜態檔案是否受保護 Spring Security的方法都是用了建造者模式，\n我們如果想得知「有沒有把static資料夾底下的檔案皆不受保護」，\n關鍵程式碼就在於在.authorizeRequests()之後，使用加上 .antMatchers(\u0026quot;/static/**\u0026quot;).permitAll()來表示此方法裡面的URL皆不受保護，所以如果把這個方法取消掉，就代表static底下的CSS、JS檔案受到保護，所以當我們檢查chrome時，會出現下列圖片\n程式碼：\n@Override protected void configure(HttpSecurity http) throws Exception { http.formLogin() .loginPage(\u0026#34;/user_login\u0026#34;).permitAll() .and() .authorizeRequests() .anyRequest().authenticated() .and() .rememberMe() .and() .csrf().disable(); } 結果：\n![302 error](302 error.jpg)\n這樣就代表我們的ftl裡面配置的css、js路徑是正確的， 但因為受到Spring Security的保護，所以就算訪問到了正確的路徑時，也會因受保護出現302的狀態碼，所以把保護關閉這樣寫就好：\n@Override protected void configure(HttpSecurity http) throws Exception { http.formLogin() //自定義登入頁面的「url」,加上permitAll()任何使用者都不需認證就可以訪問  .loginPage(\u0026#34;/user_login\u0026#34;).permitAll() .and() .authorizeRequests() //表示要定義哪些被保護，哪些不需要保護（不需要認證）  .antMatchers(\u0026#34;/static/**\u0026#34;).permitAll() //表示static底下資料夾都不需要認證  //沒有被匹配到「URL」的都要透過認證  .anyRequest().authenticated() .and() .rememberMe() .and() .csrf().disable(); //關閉csrf防護 } 這邊一樣了附上部分重點程式碼，其他的可以到文章最後的github連結參考。\nSpring Security 補充 .anyRequest().authenticated()作用 這次的練習也更認識到了.anyRequest().authenticated()的用法，如果上段程式碼沒有了.anyRequest().authenticated()之後，仍然會訪問成功，所以要加上anyRequest().authenticated()之後，任何網址才會因為加上這個方法後而受保護。\n加上.anyRequest().authenticated()後， 可以看到下面圖片，確實是有訪問到login_success的，但也因為login_success，受到保護之後Spring Security就跳轉到了我們設置的登入URL\n \nGitHub Github\n這個github是一個正在開發的專案，所以會有別的專案，\nSpring Security的配置類的Class名稱叫做SecurityConfig。\n","date":"2021-12-23T00:00:00Z","image":"https://yen0304.github.io/p/freemarker-spring-security-%E6%95%B4%E5%90%88/cover_hu3d03a01dcc18bc5be0e67db3d8d209a6_702789_120x120_fill_q75_box_smart1.jpg","permalink":"https://yen0304.github.io/p/freemarker-spring-security-%E6%95%B4%E5%90%88/","title":"Freemarker + Spring Security 整合"},{"content":"SpringBoot學習筆記-單元測試(3)-Controller層、Dao層、Service層的測試方式，MockMvc使用詳解 Dao層以及Service層的測試方式 使用JUnit5測試SpringBoot程式 @SpringBootTest註解  只要在測試用的class上面加上@SpringBootTest，就會在單元測試時啟動Spring容器，也會創建Bean出來 這個@SpringBootTest的註解的功能非常完善，除了創建Bean之外，@Configuration或是攔截器Interceptor都會被生效，也就是等同於運行SpringBoot程式。 通常會把測試用的class變成public，  做好了準備之後可以運行看看成效以及顯示的結果為何：\n@SpringBootTest public class StudentDaoImplTest { //注入bean  @Autowired private StudentDao studentDao; @Test public void getById(){ Student student = studentDao.getById(1); assertNotNull(student); assertEquals(\u0026#34;Amy\u0026#34;,student.getName()); } } 運行成果：\n \n@Transactional註解 假設今天我們透過@Test想測試deleteById的方法時，實際上是會去真實刪除資料庫裡面的數據的，所以如果先執行了測試deleteById，在執行測試getById，這時候如果Id是一樣的情況下，就會影響到測試結果，雖然可以透過測試不同的Id來避免此情況，但在越複雜的專案時此方法很不適合，所以我們可以透過加上@Transactional註解，在單元測試結束之後，SpringBoot會去rollback（回滾）這個單元測試裡面所有的資料庫操作。\n使用範例：\n@Transactional @Test public void deleteById(){ studentDao.deleteById(1); Student student =studentDao.getById(1); assertNull(student); } 不同的@Transactional註解 @Transactional在不同的資料夾下，有不同的差異，\n   資料夾 @Transactional公用     main資料夾 程式運行中發生錯誤才進行rollback   test資料夾 單元測試結束之後，強制執行rollback    Controller層的測試 Controller層的測試目的在於，要模擬前端呼叫真實API CAll的行為，看API是否能運行正確，並且不能透過注入Bean的方式來測試，意思就是模擬http request\nMockMvc MockMvc的用途在於模擬真實的API call，\n所以除了在測試用的class上面加上@SpringBootTest之外，要另外加上註解@AutoConfigureMockMvc這個註解，再注入MockMvc這項Bean。\nMockMvc使用範例、MockMvc使用詳解 這邊附上Controller層程式碼：\n@RestController public class StudentController { @Autowired private StudentService studentService; @PostMapping(\u0026#34;/students\u0026#34;) public ResponseEntity\u0026lt;Student\u0026gt; create(@RequestBody Student student) { Integer studentId = studentService.insert(student); Student newStudent = studentService.getById(studentId); return ResponseEntity.status(HttpStatus.CREATED).body(newStudent); } @PutMapping(\u0026#34;/students/{studentId}\u0026#34;) public ResponseEntity\u0026lt;?\u0026gt; update(@PathVariable Integer studentId, @RequestBody Student student) { student.setId(studentId); studentService.update(student); return ResponseEntity.status(HttpStatus.OK).build(); } @DeleteMapping(\u0026#34;/students/{studentId}\u0026#34;) public ResponseEntity\u0026lt;?\u0026gt; delete(@PathVariable Integer studentId) { studentService.deleteById(studentId); return ResponseEntity.status(HttpStatus.NO_CONTENT).build(); } @GetMapping(\u0026#34;/students/{studentId}\u0026#34;) public ResponseEntity\u0026lt;Student\u0026gt; read(@PathVariable Integer studentId) { Student student = studentService.getById(studentId); return ResponseEntity.status(HttpStatus.OK).body(student); } } 再來是Test資料夾底下的StudentDaoImplTest程式碼\n//步驟一，把class變成public，並且創建相關的註解 @SpringBootTest @AutoConfigureMockMvc public class StudentControllerTest { //步驟二，注入Bean  @Autowired private MockMvc mockMvc; //步驟三，建立測試單元  //在建立MockMvc的時候，主要會分成三個部分  @Test //後面throws Exception是因為下面的perform會去噴出一個Exception，所以才需要在方法上thorw出來  public void getById() throws Exception{ /* 第一個部分就是會去創建一個requestBuilder， requestBuilder他會決定要發起的http requst，url路徑 甚至header，他其實就是一個APItester的概念 */ //RequestBuilder也使用了Builder設計模式  RequestBuilder requestBuilder = MockMvcRequestBuilders .get(\u0026#34;/students/3\u0026#34;) //等同於 .get(\u0026#34;/students/{studentId}\u0026#34;,3);  .header(\u0026#34;headerName\u0026#34;,\u0026#34;headerValue\u0026#34;) .queryParam(\u0026#34;graduate\u0026#34;,\u0026#34;true\u0026#34;); /* 第二個部分就是mockMvc.perform()程式， 他的用途就是在執行上面的requestBuilder 這個方法就等同於在APItester按下send */ mockMvc.perform(requestBuilder) /* 第三個部分就是在perform後面的程式， andExpect這個方法就是用來驗證結果， 很像assert的概念，主要有 andDo()、andExpect、andReturn 來輸出、驗證、取得結果 */ .andExpect(MockMvcResultMatchers.status().is(200)); } } 執行後如果驗證正確的話，就會看到成功的畫面，也完成了透過MockMvc去完成測試\nＭockMvc常用寫法 設計者模式（Builder） Perform方法寫法，以及所謂的Builder設計模式，這個模式的核心概念就是可以無限「.」下去\n範例：\nmockMvc.perform(requestBuilder) .andExpect(MockMvcResultMatchers.status().is(200)) .andExpect() .andExpect() 驗證Json格式資料-jsonPath方法 如果要驗證Json格式資料的話，我們就需要用jsonPath方法，\n在jsonPath方法裡第一個參數就是想要取得json object的key，第二個則是要驗證的方式。\n其中特別的是第一個參數，他設計了使用者如果要使用的話，要用代表最外層json object的\u0026quot;$\u0026ldquo;符號，還有「.」符號來取的我們想要的數據。 那對於jsonPath的這種方式，這邊提供了\njsonpath練習網站-JSONPath Online Evaluator 來幫助我們練習，這個網站叫做JSONPath Online Evaluator，使用方式很簡單，如下圖：\n jsonpath \n.andDo() 其實在撰寫jsonpath時，要一邊撰寫jsonpath時還要一邊查看json數據其實是有點麻煩的事情，因為在測時前要先去的json數據，所以我們可以透過.andDo先來輸出.perform的API執行結果當執行測試單元時，其中會長這樣：\n部分java程式碼：\npublic void getById() throws Exception{ RequestBuilder requestBuilder = MockMvcRequestBuilders .get(\u0026#34;/students/3\u0026#34;); mockMvc.perform(requestBuilder) //當在.perform下面使用.andDo的時候，就可以輸出這個API的執行結果  .andDo(print()) .andExpect(status().is(200)) /*這邊的equal使用萬用鍵的方式import static method之後在選擇Machers.equalTo 第一個就是想要取得json object的key, ＄的意思就是最外層的json object 「.」就是所謂的\u0026#34;的\u0026#34; */ .andExpect(jsonPath(\u0026#34;$.id\u0026#34;,equalTo(3))) .andExpect(jsonPath(\u0026#34;$.name\u0026#34;,notNullValue())); } 部分console：\n在console裏面首先可看到MockHttpServletRequest寫著http request的資訊，\n再來下面的MockHttpServletResponse資訊裡，就是程式裡面運行的結果， 也可以看到在Body裡面有返回的json格式結果，在撰寫json時效率就能稍微高一些些。\nMockHttpServletRequest: HTTP Method = GET Request URI = /students/3 Parameters = {} Headers = [] Body = null Session Attrs = {} Handler: Type = com.example.demo.controller.StudentController Method = com.example.demo.controller.StudentController#read(Integer) Async: Async started = false Async result = null Resolved Exception: Type = null ModelAndView: View name = null View = null Model = null FlashMap: Attributes = null MockHttpServletResponse: Status = 200 Error message = null Headers = [Content-Type:\u0026#34;application/json\u0026#34;] Content type = application/json Body = {\u0026#34;id\u0026#34;:3,\u0026#34;name\u0026#34;:\u0026#34;Judy\u0026#34;,\u0026#34;score\u0026#34;:100.0,\u0026#34;graduate\u0026#34;:true,\u0026#34;createDate\u0026#34;:\u0026#34;2021-09-05T04:19:48.000+00:00\u0026#34;} Forwarded URL = null Redirected URL = null Cookies = [] .andReturn 在上面.andDo()的程式裡面，還可以透過andReturn來驗證結果，但他只能加在最後一行，他的用途是取得完整的API執行結果出來，一般在比較複雜的test case才會使用，不然在except加上jsonpath就夠用了，所以我們將上面的程式碼改版後會變成這樣：\n@Test public void getById() throws Exception{ RequestBuilder requestBuilder = MockMvcRequestBuilders .get(\u0026#34;/students/3\u0026#34;); //下面這行有改變，使用了MvcResult，可以去對照andDo看看有什麼不同  MvcResult mvcResult=mockMvc.perform(requestBuilder) .andDo(print()) .andExpect(status().is(200)) .andExpect(jsonPath(\u0026#34;$.id\u0026#34;,equalTo(3))) .andExpect(jsonPath(\u0026#34;$.name\u0026#34;,notNullValue())) .andReturn(); //使用mvcResult取得responseBody資訊  String body =mvcResult.getResponse().getContentAsString(); //顯示  System.out.println(\u0026#34;返回的responseBody為：\u0026#34;+ body); } MockMvc POST方法 上面示範了使用MockMvc來寫出GET方法的http request， 接下來要學習使用POST，用程式碼來解說\n@Test public void create() throws Exception{ RequestBuilder requestBuilder = MockMvcRequestBuilders .post(\u0026#34;/students\u0026#34;) //到上面都跟get幾乎一樣  //下面很重要，一定要加上下面這行才可以在requestBody才可以傳遞json參數  .contentType(MediaType.APPLICATION_JSON); //想在request Body的json字串  //.content(.....)  //執行  mockMvc.perform(requestBuilder) //查看創建的API的成功http狀態碼決定  .andExpect(status().is(201)); } Github github\n本範例皆由hahow古老師的課程學習，範例也是，\n想要深入了解課程可參考\n","date":"2021-12-22T00:00:00Z","image":"https://yen0304.github.io/p/springboot%E5%AD%B8%E7%BF%92%E7%AD%86%E8%A8%98-%E5%96%AE%E5%85%83%E6%B8%AC%E8%A9%A63-controller%E5%B1%A4dao%E5%B1%A4service%E5%B1%A4%E7%9A%84%E6%B8%AC%E8%A9%A6%E6%96%B9%E5%BC%8Fmockmvc%E4%BD%BF%E7%94%A8%E8%A9%B3%E8%A7%A3/logo_hud02855c89443ca066a520da3d79109c3_149566_120x120_fill_box_smart1_3.png","permalink":"https://yen0304.github.io/p/springboot%E5%AD%B8%E7%BF%92%E7%AD%86%E8%A8%98-%E5%96%AE%E5%85%83%E6%B8%AC%E8%A9%A63-controller%E5%B1%A4dao%E5%B1%A4service%E5%B1%A4%E7%9A%84%E6%B8%AC%E8%A9%A6%E6%96%B9%E5%BC%8Fmockmvc%E4%BD%BF%E7%94%A8%E8%A9%B3%E8%A7%A3/","title":"SpringBoot學習筆記-單元測試(3)-Controller層、Dao層、Service層的測試方式，MockMvc使用詳解 "},{"content":"SpringBoot學習筆記-單元測試(2)-JUnit JUnit介紹 何謂JUnit?  jUnit是java單元測試的必備工具 只要在方法上加入@Test，即可生成一個單元測試  JUnit與Spring Boot的關係   Spring Boot \u0026lt;=2.1\n只能使用JUnit4\n  Spring Boot 2.2 2.3\n可以使用JUnit4、JUint5。\n  Spring boot \u0026gt;=2.4\n只能使用JUnit5\n  所以綜合上述，現階段會以Junit5作為主流，其中需要注意的是，Spring Boot如果在2.2以及2.3版本中，需要到pom.xml加上額外設定才能禁用JUint4。\n在Spring Boot 2.2版本或2.3版本禁用JUnit4 如果需要在Spring Boot 2.2版本或2.3版本禁用JUnit4在pom.xml中，我們的程式碼其中有關測試單元的大致上會長這樣：\n\u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-test\u0026lt;/artifactId\u0026gt; \u0026lt;scope\u0026gt;test\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; 我們只需新增下面這幾段程式碼即可禁用JUnit4，上面那段程式碼會變成這樣：\n\u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-test\u0026lt;/artifactId\u0026gt; \u0026lt;scope\u0026gt;test\u0026lt;/scope\u0026gt; \u0026lt;exclusions\u0026gt; \u0026lt;exclusion\u0026gt; \u0026lt;groupId\u0026gt;org.junit.vintage\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;junit-vintage-engine\u0026lt;/artifactId\u0026gt; \u0026lt;/exclusion\u0026gt; \u0026lt;/exclusions\u0026gt; \u0026lt;/dependency\u0026gt; Junt5的用法 Junit5的用法 以圖片說明：\n \n其中第三點看起來簡單，但正是最精華的所在處，因為如果要讓團隊或是別人看懂這個方法的作用，命名正是我們最重要的工作。\nJUnit5 Assert 下面用表格來說明Assert斷言用法的主要用途\n   Assert系列用法 用途     assertNull(A) 斷言A為Null   assertNotNull(A) 斷言A不為Null   assertEquals(A,B) 斷言A與B相等   assertTure(A) 斷言A為True   assertFalse(A) 斷言A為False   assertThrows(exception,method) 斷言執行method的時候，會噴出exception    JUnit其他常用註解 @BeforceEach @BeforceEach：在每次@Test開始之前，「都會」執行一次\n@AfterEach @AfterEach：在每次@Test結束之後，「都會」執行一次\n範例：\nclass CalcultorTest { @AfterEach public void after(){ System.out.println(\u0026#34;執行after\u0026#34;); } @BeforeEach public void beforce(){ System.out.println(\u0026#34;執行beforce\u0026#34;); } @Test public void test1() { System.out.println(\u0026#34;執行test1\u0026#34;); } @Test public void test2() { System.out.println(\u0026#34;執行test2\u0026#34;); } } 執行結果：\n/*----------- 執行beforce 執行test1 執行after 執行beforce 執行test2 執行after ------------*/ @BeforceAll @BeforceAll：在所有@Test開始前執行一次\n@AfterAll @AfterAll：在所有@Test結束之後執行一次\n在使用@AfterAll還有@BeforceAll的時候，必須是static才行，\n也由於他們是static的原因，所以就不能去操做spring中的bean，所以比較少使用。\nclass CalcultorTest { @AfterAll public static void afterall(){ System.out.println(\u0026#34;執行@AfterAll\u0026#34;); } @BeforeAll public static void beforceall(){ System.out.println(\u0026#34;執行@BeforceAll\u0026#34;); } @Test public void test1() { System.out.println(\u0026#34;執行test1\u0026#34;); } @Test public void test2() { System.out.println(\u0026#34;執行test2\u0026#34;); } } 執行結果：\n/*----------- 執行@BeforceAll 執行test1 執行test2 執行@AfterAll -------------*/ ＠Disabled Disabled：忽略該@Test不執行\n@DisplayName DisplayName：自定義顯示名稱\n範例：\n這是沒有使用註解狀況下的程式碼以及運行結果\n程式碼：\n@Test public void test1() { System.out.println(\u0026#34;執行test1\u0026#34;); } @Test public void test2() { System.out.println(\u0026#34;執行test2\u0026#34;); } 運行結果：\n \n程式碼：\n@DisplayName(\u0026#34;這個是自定義的test1名稱\u0026#34;) @Test public void test1() { System.out.println(\u0026#34;執行test1\u0026#34;); } @Disabled @Test public void test2() { System.out.println(\u0026#34;執行test2\u0026#34;); } 運行結果：\n \ngithub連結： github\n","date":"2021-12-20T00:00:00Z","image":"https://yen0304.github.io/p/springboot%E5%AD%B8%E7%BF%92%E7%AD%86%E8%A8%98-%E5%96%AE%E5%85%83%E6%B8%AC%E8%A9%A62-junit5%E4%BD%BF%E7%94%A8%E6%95%99%E5%AD%B8/logo_hud02855c89443ca066a520da3d79109c3_149566_120x120_fill_box_smart1_3.png","permalink":"https://yen0304.github.io/p/springboot%E5%AD%B8%E7%BF%92%E7%AD%86%E8%A8%98-%E5%96%AE%E5%85%83%E6%B8%AC%E8%A9%A62-junit5%E4%BD%BF%E7%94%A8%E6%95%99%E5%AD%B8/","title":"SpringBoot學習筆記-單元測試(2)-JUnit5使用教學"},{"content":"SpringBoot學習筆記-單元測試(1) 在學了SpringBoot中，不少的核心知識CRUD操作，接下來要學習的是該如何去測試我們撰寫好的功能\n何謂單元測試（Unit Testing）？ 目的：自動化測試程式的正確性\n所謂的單元測試，就是一次只測試一個功能點，一個單元可以是一個method，或是一個API\n單元測試的特性＆注意事項 單元測試的特性 1.可以被自動化運行\n2.各個單元測試互相獨立，彼此之間不能有依賴關係\n3.測試結果穩定，不受外部服務影響\n單元測試的注意事項 1.測試的程式要放在test資料夾裡面\n2.測試的class名稱以「原class的名字加上Test做為結尾」來命名\n3.測試的class的package要跟原class的package保持一致\n環境部署\u0026amp;基礎範例  環境部署 如果想要在springboot裡面使用單元測試功能，要在pom.xml裏面新增這個maven，不過這段程式碼在一般創建springboot程式中就會加上去了\n\u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-test\u0026lt;/artifactId\u0026gt; \u0026lt;scope\u0026gt;test\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt;  開始測試 先在demo的package底下新增一個簡易的計算機class Calcultor ，\n首先如果我們一般在進行撰寫時，程式大概會長這樣：\npublic class Calcultor { public int add(int x,int y){ return(x+y); } public static void main(String[] args) { Calcultor calcultor =new Calcultor(); int result = calcultor.add(1,2); System.out.println(\u0026#34;結果為\u0026#34; + result); } } 結果會理所當然的出現結果為3，但假設今天某個工程師在add方法裡寫錯了，就必須花時間去尋找add方法裡是否有錯誤，所以我們這時候就要去利用單元測試去完成自動化測試。\n首先在Calcultor 裡面點擊右鍵，選擇Generate-\u0026gt;Test ，Testing Library選擇JUnit5 如下圖：\n \n接著就可以看到在Test底下的demo Package看到CalculatorTest這個Class，我們用以下程式碼來完成第一個測試的程式：\nclass CalcultorTest { //加上@Test註解，要使用org.junit.jupiter.api這一個  @Test public void test() { Calcultor calcultor = new Calcultor(); int result = calcultor.add(1, 2); //以上應該都不用解釋  //接下來最重要,assertEquals就是斷言，也就是我認為的意思，格式如下  // assertEquals(expected應該要是多少,result變數(結果));  assertEquals(3,result); } }  \n當我們完成上面add方法的返回值時，就算是自動化測試了\n","date":"2021-12-19T00:00:00Z","image":"https://yen0304.github.io/p/springboot%E5%AD%B8%E7%BF%92%E7%AD%86%E8%A8%98-%E5%96%AE%E5%85%83%E6%B8%AC%E8%A9%A61-%E5%9F%BA%E7%A4%8E%E4%BB%8B%E7%B4%B9/logo_hud02855c89443ca066a520da3d79109c3_149566_120x120_fill_box_smart1_3.png","permalink":"https://yen0304.github.io/p/springboot%E5%AD%B8%E7%BF%92%E7%AD%86%E8%A8%98-%E5%96%AE%E5%85%83%E6%B8%AC%E8%A9%A61-%E5%9F%BA%E7%A4%8E%E4%BB%8B%E7%B4%B9/","title":"SpringBoot學習筆記-單元測試(1)-基礎介紹"},{"content":"前置作業 前置作業方面，需要先在資料庫中新增使用者數據，並完成使用JDBC進行登入帳密的功能，可以參考\nSpring Security(2)使用Spring Security自定義使用者帳密、使用JDBC串接資料庫，然後先新增一筆使用者帳密，並權限設定為ROLE_USER\n@EnableGlobalMethodSecurity @EnableGlobalMethodSecurity這個註解是表示，我們要透過@Securitd， @PreAuthorize，@RolesAllowed這些註解，並透過用戶權限來訪問我們的方法\n第一種使用方式：\n@EnableGlobalMethodSecurity的用法就是加在配置類中就可以了，當然我們熟悉的@configuration是用來表示此類別是用來設定springboot用的，@EnableGlobalMethodSecurity已經包含了@configuration，所以我們直接在我們繼承WebSecurityConfigurerAdapter的類別上面加上@EnableGlobalMethodSecurity註解即可\n@EnableGlobalMethodSecurity public class SecurityConfig extends WebSecurityConfigurerAdapter { //... } 第二種是用方式：\n放在啟動類上面(Application)。\n@EnableGlobalMethodSecurity @SpringBootApplication public class DemoApplication { public static void main(String[] args) { SpringApplication.run(DemoApplication.class, args); } } 而如果要使用@Secured、@PreAuthorize、@PostAuthorize，的話都要先開啟註解功能，也就是在我們的@EnableGlobalMethodSecurity加上(Securitd=true)、(prePostEnabled = true)、\n舉例：\n開啟@Secured功能\n@EnableGlobalMethodSecurity(securedEnabled=true)\n開啟@PreAuthorize或是@PostAuthorize\n@EnableGlobalMethodSecurity(securedEnabled = true,prePostEnabled = true) 如果要同時使用的話，@EnableGlobalMethodSecurity(securedEnabled = true,prePostEnabled = true)，就可以了\n四種加在方法上的註解 主要是@Securitd、@PreAuthorize最為常用，\n所以下面實作中會解釋兩者最大的差別\n   Security Annotation (註解) 使用時機     @Secured 用戶有某個角色，驗證後進行方法   @PreAuthorize 在方法執行之前進行驗證，並能將用戶的roles/premission參數傳入到方法中   @PostAuthorize 在方法執行之後，在進行驗證   @PostFilter 將方法的返回數值進行過濾   @PreFilter 將傳入方法的值進行過濾    實作 以下實作最常使用到的@Secured以及@PreAuthorize，可以發現@PreAuthorize在設定權限參數中，使用了hasAnyAuthority加入前綴，使權限在資料庫的名稱為ROLE_USER，hasAnyAuthority是spring EL表示式（Spring Expression Language）的一種，@Secured並沒有支援spring EL表示式，且也沒有像@PreAuthorize可以將驗證的參數傳入方法中，所以簡單來說@PreAuthorize就是@Secured的加強版\n共同設定、部分程式碼 @EnableGlobalMethodSecurity(securedEnabled = true,prePostEnabled = true) public class SecurityConfig extends WebSecurityConfigurerAdapter { @Autowired private DataSource dataSource; //使用jdbc來進行用戶登入，固定寫法  @Override protected void configure(AuthenticationManagerBuilder auth) throws Exception { String sql=\u0026#34;SELECT username,updatepassword,enabled FROM t_user WHERE username=?\u0026#34;; String authorsql=\u0026#34;SELECT username,role FROM t_user WHERE username=?\u0026#34;; auth.jdbcAuthentication() .dataSource(dataSource) .usersByUsernameQuery(sql) .authoritiesByUsernameQuery(authorsql) .passwordEncoder(new BCryptPasswordEncoder()); } @Override protected void configure(HttpSecurity http) throws Exception { //http.formLogin().....  } @Bean PasswordEncoder password() { return new BCryptPasswordEncoder(); } } @Secured Controller：\n@GetMapping(\u0026#34;/test\u0026#34;) @Secured(\u0026#34;ROLE_USER\u0026#34;) public String test(){ return (\u0026#34;Secured驗證成功\u0026#34;); } 如果要匿名訪問的話，使用@Secured(\u0026ldquo;IS_AUTHENTICATED_ANONYMOUSLY\u0026rdquo;)就可以了，不過不用加應該更快（？\n@PreAuthorize @GetMapping(\u0026#34;/test2\u0026#34;) @PreAuthorize(\u0026#34;hasAnyAuthority(\u0026#39;USER\u0026#39;)\u0026#34;) //=@PreAuthorize(\u0026#34;hasRole(\u0026#39;ROLE_USER\u0026#39;)\u0026#34;) public String test2(){ return (\u0026#34;PreAuthorize驗證成功\u0026#34;); } 實際運行 以輸入localhost:8080/test為例，會先出現預設的登入畫面：\n springboot預設登入畫面 \n接著使用資料庫的帳號密碼進行登入，這裡我分別準備了兩組帳號，\n第一組角色ROLE_ADMIN進行登入：\n ROLE_ADMIN登入結果 \n會出現AccessDenied錯誤，雖然登入成功但是被擋住了，\n如果是用第二組角色ROLE_USER登入：\n ROLE_USER登入結果 \n","date":"2021-09-18T00:00:00Z","image":"https://yen0304.github.io/p/spring-security4%E8%A8%AA%E5%95%8F%E6%AC%8A%E9%99%90%E8%A8%BB%E8%A7%A3securitdpreauthorize/logo_huf957eb7cc0803733802fcc4099cfd7cb_45239_120x120_fill_q75_box_smart1.jpeg","permalink":"https://yen0304.github.io/p/spring-security4%E8%A8%AA%E5%95%8F%E6%AC%8A%E9%99%90%E8%A8%BB%E8%A7%A3securitdpreauthorize/","title":"Spring Security(4)訪問權限註解@Securitd、@PreAuthorize"},{"content":"前言 在前一章Spring Security(2)使用Spring Security自定義使用者帳密、使用JDBC串接資料庫中，我們知道了如何透過Spring Security自定義的角色來訪問我們的頁面，接下來要做的是，如何設定哪些頁面不用登入跟可以訪問、哪些頁面有帳號密碼到才可以訪問，或是我們自定義的權限角色管理員、銷售員、就像賣場的賣家與用戶一樣，去控制這些頁面，也將訪問頁面設定成前端設計好的頁面，實現真正的前後端分離，減少溝通成本。\n自定義登入頁面 要自定義頁面時，一樣到專門設定Spring Security中的一個類別WebSecurityConfigurerAdapter，在前幾章中我們用了SecurityConfig去繼承他，在自定義頁面時，我們要先實作方法configure(HttpSecurity http)，一樣按右鍵-\u0026gt;Generate-\u0026gt;Override Methods，選擇configure(HttpSecurity http)。\n在使用之前，值得注意的事情是SecurityConfig的antMatchers順序是有關係的，在每一個url執行時，程式如果返回了True下面就不會執行了，例如，如果anyRequest().permitAll()設定在其他規則比較嚴格條件的前面的話，Spring Security判斷符合條件，就不會往下在走，意思是最鬆的規則應該在放在最後面，越是嚴格的規則要放在前面。\n下面範例提供了幾個較常用的功能，如下：\n@Override protected void configure(HttpSecurity http) throws Exception { http.formLogin() //自定義登入頁面  .loginPage(\u0026#34;/login.html\u0026#34;) .loginProcessingUrl(\u0026#34;/user/login\u0026#34;) //設定登入頁面的url  .usernameParameter(\u0026#34;uname\u0026#34;)///登入表單form中使用者名稱輸入框input的name名，不修改的話預設是username  .passwordParameter(\u0026#34;pword\u0026#34;)//form中密碼輸入框input的name名，不修改的話預設是password  .defaultSuccessUrl(\u0026#34;/home\u0026#34;) //成功登入之後導向  .and().authorizeRequests() //表示要定義哪些被保護(.authenticated())，哪些不需要保護（authorizeRequests()）  .antMatchers(\u0026#34;/\u0026#34;,\u0026#34;/hello\u0026#34;).permitAll() //設置不管有無登入都可以直接訪問(permitAll)  .anyRequest().authenticated() //這樣寫代表除了以上之外，其他都需要被保護  .and().csrf().disable(); //關閉csrf防護 } 選擇角色權限進行控制的四種方法 在Spring Security中，我們可以針對用戶的角色進行訪問頁面的權限控制，例如說，設定某些頁面管理員才能訪問，有些頁面大家都可以訪問，或是自定義的角色等等，針對各種不同的情況，共有四種方法，返回都是True or False\n四種方法比較表格    方法名稱 舉例 意思     hasAuthority(String authority) hasAuthority(\u0026ldquo;ADMIN\u0026rdquo;) ADMIN角色才可以訪問   hasAnyAuthority(String\u0026hellip; authorities) hasAnyAuthority(\u0026ldquo;ADMIN,MANAGER\u0026rdquo;) 有ADMIN或MANAGER其中一個符合就可以訪問   hasRole(String role) hasRole(\u0026ldquo;Sale\u0026rdquo;) 角色權限全名ROLE_Sale才可以訪問   hasAnyRole(String\u0026hellip; roles) hasAnyRole(\u0026ldquo;Sale,User\u0026rdquo;) 有角色權限全名ROLE_Sale或ROLE_User其中一者就可以訪問    hasAuthority()跟 hasRole()的雖然很像，其實都是設定角色是否可以訪問，但是如果查看一下hasRole()的來源碼，就可以知道差別\nprivate static String hasRole(String role) { Assert.notNull(role, \u0026#34;role cannot be null\u0026#34;); if (role.startsWith(\u0026#34;ROLE_\u0026#34;)) { throw new IllegalArgumentException(\u0026#34;role should not start with \u0026#39;ROLE_\u0026#39; since it is automatically inserted. Got \u0026#39;\u0026#34; + role + \u0026#34;\u0026#39;\u0026#34;); } else { return \u0026#34;hasRole(\u0026#39;ROLE_\u0026#34; + role + \u0026#34;\u0026#39;)\u0026#34;; } } 以上我們可以發現，如果在程式裡面設計hasRole(\u0026ldquo;Sale\u0026rdquo;)代表在資料庫中，實際上角色全名為ROLE_Sale的才能進行登入，相同的hasAnyRole也是相同的道理。\n超級重點.authenticated()、.authorizeRequests() （ 20220109更新） authenticated()的作用，很後面才了解到，他的功能表示登入才可以訪問一切的網址，他其實是Spring Security最重要的一部份，如果沒有加上了他，網址就不會被攔截，可以想像成他就是關閉Spirng Security的一個方法，我也正是理解到了架構。\nprotected void configure(HttpSecurity http) throws Exception { http.formLogin() //自定義登入頁面  //放有關於登入頁面的設定  .and().authorizeRequests() //放有關於設定網址的問題，透過.permitAll()來表示不需要被保護的網址  //或是其他特別的設定  .anyRequest().authenticated() //再加上這個之後，就變成了除了上面設定以外的網址，其他都需要登入  .and().csrf().disable(); //關閉防護 } 所以通常會這樣設計（上到下權限）：\nprotected void configure(HttpSecurity http) throws Exception { http.formLogin() //自定義登入頁面  .loginPage(\u0026#34;/login.html\u0026#34;) .loginProcessingUrl(\u0026#34;/user/login\u0026#34;) //設定登入頁面的url  .defaultSuccessUrl(\u0026#34;home\u0026#34;) //成功登入之後導向  .and().authorizeRequests() //表示要定義哪些被保護，哪些不需要保護（不需要認證）  //先設定不用通過的  .antMatchers(\u0026#34;/\u0026#34;,\u0026#34;hello\u0026#34;).permitAll() //角色權限配置篇  .antMatchers(\u0026#34;/manager\u0026#34;).hasAuthority(\u0026#34;ADMIN\u0026#34;) .antMatchers(\u0026#34;/manager_2\u0026#34;).hasAnyAuthority(\u0026#34;ADMIN,MANAGER\u0026#34;) .antMatchers(\u0026#34;/sale_index\u0026#34;).hasRole(\u0026#34;Sale\u0026#34;) .antMatchers(\u0026#34;/role\u0026#34;).hasAnyRole(\u0026#34;Sale\u0026#34;) .anyRequest().authenticated() //  .and().csrf().disable(); //關閉防護 } 自定義403頁面 在配置類裡面進行設定沒有權限時返回的頁面403碼，html檔案放在resources/static就可以了\nprotected void configure(HttpSecurity http) throws Exception { http.exceptionHandling().accessDeniedPage(\u0026#34;/403.html\u0026#34;); } 實作 接下來實作方面，我想結合對於資料庫的CRUD做複習，模擬在電商平台做開發時的情況，所以先這樣！\n","date":"2021-09-12T00:00:00Z","image":"https://yen0304.github.io/p/spring-security3%E8%87%AA%E5%AE%9A%E7%BE%A9%E7%99%BB%E5%85%A5%E9%A0%81%E9%9D%A2%E6%8E%A7%E5%88%B6%E8%A7%92%E8%89%B2%E6%AC%8A%E9%99%90%E7%99%BB%E5%85%A5/logo_huf957eb7cc0803733802fcc4099cfd7cb_45239_120x120_fill_q75_box_smart1.jpeg","permalink":"https://yen0304.github.io/p/spring-security3%E8%87%AA%E5%AE%9A%E7%BE%A9%E7%99%BB%E5%85%A5%E9%A0%81%E9%9D%A2%E6%8E%A7%E5%88%B6%E8%A7%92%E8%89%B2%E6%AC%8A%E9%99%90%E7%99%BB%E5%85%A5/","title":"Spring Security(3)自定義登入頁面、控制角色權限登入"},{"content":"繼上一章了解到了Spring Security基本的作用之後，本章節來繼續深入瞭解有關Spring Security中權限還有認證的相關設置，以及如何串接MySql資料庫數據來進行用戶認證 大概會用到的核心功能有JDBC Authentication、WebSecurityConfigurerAdapter、UserDetailsService\n自訂用戶、查詢資料庫中帳號密碼 在Spring Security中，自訂登入系統的帳號與密碼主要有二種方法兩種，第一種就是透過程式設定來在後臺上寫上固定的自定義帳號密碼，第二種則是\n添加依賴 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-security\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; 配置application.properties 語法如下，也是最簡單的方式，在resource下找到application.properties並輸入：\nspring.security.user.name=testad #自定義帳號 spring.security.user.password=abc123 #自定義密碼 透過繼承類別WebSecurityConfigurerAdapter 先新增一個類別SecurityConfig來繼承WebSecurityConfigurerAdapter，WebSecurityConfigurerAdapter是專門用來配置Spring Security的一個類別：\n@Configuration //小複習:當@Configuration加在class上，表示這是一個設定spring用的class（裡面寫的東西都是設定spring) public class SecurityConfig extends WebSecurityConfigurerAdapter { //... } 再來使用configure方法來設置我們的用戶設定，在IDEA中點擊右鍵-\u0026gt;Generate-\u0026gt;Override Methods選擇我們要覆寫的方法configure(AuthenticationManagerBuilder auth)（真是方便）\n會出現：\n@Override protected void configure(AuthenticationManagerBuilder auth) throws Exception { super.configure(auth); } 在這個方法中，主要透過auth來設置我們的用戶名以及密碼，但在下面得例子中，也使用了Spring Security提供了類別的BCryptPasswordEncoder來加密我們的密碼，在使用BCryptPasswordEncoder時，因為我們改變了password()的接受參數類型，所以也要記得使用@Bean來實作一個password類型\n@Bean PasswordEncoder password(){ return new BCryptPasswordEncoder(); } 再來就是Spring Security在進行安全驗證時，會收到輸入請求中的使用者名稱(username)，然後呼叫UserDetailsService，UserDetailsService是Spring Security用來載入使用者資訊的一個組件，他的功能就是可以提供UserDetailsService中的一個方法loadUserByUsername(String username)，來依據username回傳資料型別UserDetails的使用者資訊（參考文章：Spring Security UserDetailsService 用途)\n所以我們先\n實作UserDetailsService 在implements UserDetailsService的時候，只需要實作一個方法就好，那就是loadUserByUsername，在學習這裡時，稍微了解到了@Service以及＠Component的差別，就是除了閱讀讓人知道Service是處理業務邏輯之外，實際上功能其實都是一樣讓class變成Bean。\n//MyUsersDetailService完整程式碼：  @Service public class MyUsersDetailService implements UserDetailsService { @Override public UserDetails loadUserByUsername(String s) throws UsernameNotFoundException { //權限(固定用法,role是還沒用到所以拿來暫時先隨便亂取）  List\u0026lt;GrantedAuthority\u0026gt; auths = AuthorityUtils.commaSeparatedStringToAuthorityList(\u0026#34;role\u0026#34;); //return 用戶名稱,密碼,用戶角色（權限），用戶角色不可以為Null!  return new User(\u0026#34;testusername\u0026#34;,new BCryptPasswordEncoder().encode(\u0026#34;abc123\u0026#34;),auths); } } 再來就是在SecurityConfig使用@Autowird,但會發現：\n autowird錯誤 \n這是因為springboot找到兩個相同類型的Bean，但只要加上@Qualifier就可以解決了（複習：bean名字是class名稱第一個字轉成小寫）\n所以變成這樣：\n@Autowired @Qualifier(\u0026#34;myUsersDetailService\u0026#34;) private UserDetailsService userDetailsService; 到這裡，就可以嘗試使用帳號testusername，密碼abc123登入頁面了，完整的SecurityConfig程式碼如下：\n@Configuration //小複習:當@Configuration加在class上，表示這是一個設定spring用的class（裡面寫的東西都是設定spring) public class SecurityConfig extends WebSecurityConfigurerAdapter { @Autowired @Qualifier(\u0026#34;myUsersDetailService\u0026#34;) private UserDetailsService userDetailsService; @Override protected void configure(AuthenticationManagerBuilder auth) throws Exception { auth.userDetailsService(userDetailsService).passwordEncoder(password()); } @Bean PasswordEncoder password(){ return new BCryptPasswordEncoder(); } } 透過以上步驟就算是可以在程式裡面新增自定義的用戶帳號密碼了，接下來就是要嘗試連接MySql資料庫來透過Spring Security做登入，在這之前其實有稍微了解了一下大致上有兩種方法，第一種方法是由上面的程式繼續使用Spring Security結合MyBatis，主要就是在另外在 MyUsersDetailService中利用MyBatis＋Mapper的方式對資料庫做操作把return值稍微更改成資料庫查詢出來的數據並在驗證，詳細介紹影片：youtube\n透過MySql以及JDBC來做登入-jdbcAuthentication 第二種方法其實Spring Security 提供了 JDBC User Service，比起在前面實作UserDetailsService的時，會少了很多步驟，Spring Security提供的JDBC User Service設定也比較簡單，首先需要加入相關的依賴：\n添加Maven配置 添加了JDBC、ＭySql\n\u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-jdbc\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- https://mvnrepository.com/artifact/mysql/mysql-connector-java --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;mysql\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;mysql-connector-java\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;8.0.22\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 資料庫設定 簡單的設定一下資料庫\n \n在使用jdbcAuthentication時，可以先稍微了解下面函式：\n   函式 功能     jdbcAuthentication() 表示我們正在使用 JDBC 身份驗證，固定寫法   dataSource(Datasource dataSource) 表示我們正在使用 JDBC 身份驗證，固定寫法   usersByUsernameQuery(String query) 設定查找用戶資料的sql語句   authoritiesByUsernameQuery(String query) 設定查找用戶權限的sql語句    知道了這些之後，在Spring Security使用 JDBC時，寫法跟格式是相對固定的，但也是官方建議的寫法，有要求在執行sql的語句usersByUsernameQuery有三樣東西不能少回傳，也就是説在Table裡面一定要有這些數據，就是帳號（username)、密碼(password)、以及是否啟用(Enabled)，authoritiesByUsernameQuery則是要求帳號（username)、以及角色(role)，且一定要使用到上面那些函式，如果我們沒有回傳權限的話，錯誤訊息大致上會長這樣：\n \n所以我們就開始設定的Database，以及先創造使用者資料如下：\nCREATEDATABASEsecuritydataCREATETABLEusers(idINTPRIMARYKEYAUTO_INCREMENT,usernameVARCHAR(30),passwordVARCHAR(60),roleVARCHAR(30),enabledTINYINT)INSERTINTOusers(username,password,role,enabled)VALUES(\u0026#39;admin\u0026#39;,\u0026#39;abc123\u0026#39;,\u0026#39;ROLE_ADMIN\u0026#39;,1)INSERTINTOusers(username,password,role,enabled)VALUES(\u0026#39;uuu123\u0026#39;,\u0026#39;ccc123\u0026#39;,\u0026#39;ROLE_USER\u0026#39;,1)INSERTINTOusers(username,password,role,enabled)VALUES(\u0026#39;123456\u0026#39;,\u0026#39;dog555\u0026#39;,\u0026#39;ROLE_USER\u0026#39;,1)INSERTINTOusers(username,password,role,enabled)VALUES(\u0026#39;888\u0026#39;,\u0026#39;yuyu\u0026#39;,\u0026#39;ROLE_USER\u0026#39;,0)接著就在SecurityConfig裡面完成我們的設定，\n@Configuration //小複習:當@Configuration加在class上，表示這是一個設定spring用的class（裡面寫的東西都是設定spring) public class SecurityConfig extends WebSecurityConfigurerAdapter { @Autowired private DataSource dataSource; @Override protected void configure(AuthenticationManagerBuilder auth) throws Exception { String sql=\u0026#34;SELECT username,password,enabled FROM users WHERE username=?\u0026#34;; String authorsql=\u0026#34;SELECT username,role FROM users WHERE username=?\u0026#34;; auth.jdbcAuthentication() .dataSource(dataSource) .usersByUsernameQuery(sql) .authoritiesByUsernameQuery(authorsql) .passwordEncoder(new BCryptPasswordEncoder()); } } 完成了之後，我們嘗試運行程式並且登入會出現下面的畫面：\n \n原因是因為，我們在configure裡面使用了passwordEncoder做加密，但是對於sql資料庫來說，密碼卻沒有加密，所以我們就直接使用update寫法，幫我們先產生出加密完的密碼並存放到資料庫，這邊要記得在資料庫中password VARCHAR(60)是因為加密後的長度會超過本來設定的(30)所以我參考了網路上給的長度(60)\n完整程式碼長這樣：\n@Configuration //小複習:當@Configuration加在class上，表示這是一個設定spring用的class（裡面寫的東西都是設定spring) public class SecurityConfig extends WebSecurityConfigurerAdapter { @Autowired private DataSource dataSource; @Autowired private NamedParameterJdbcTemplate namedParameterJdbcTemplate; @Override protected void configure(AuthenticationManagerBuilder auth) throws Exception { BCryptPasswordEncoder encoder=new BCryptPasswordEncoder(); //設定自定義密碼  String rawpassword = \u0026#34;ccc123\u0026#34;; //設定變數，這個變數存放加密完成後的密碼  String encodepassword =encoder.encode(rawpassword); String encodesql=\u0026#34;UPDATE users SET password=:userpassword WHERE username=\u0026#39;uuu123\u0026#39;\u0026#34;; Map\u0026lt;String, Object\u0026gt; map =new HashMap\u0026lt;\u0026gt;(); map.put(\u0026#34;userpassword\u0026#34;,encodepassword); namedParameterJdbcTemplate.update(encodesql,map); //要記得上面會一直重複，算是臨時性測試用的  String sql=\u0026#34;SELECT username,password,enabled FROM users WHERE username=?\u0026#34;; String authorsql=\u0026#34;SELECT username,role FROM users WHERE username=?\u0026#34;; // auth.userDetailsService(userDetailsService).passwordEncoder(password());  auth.jdbcAuthentication() .dataSource(dataSource) .usersByUsernameQuery(sql) .authoritiesByUsernameQuery(authorsql) .passwordEncoder(new BCryptPasswordEncoder()); } } 運行程式看到Started DemoApplication後，可以直接看到Table資料已經改變：\n \n之後就可以登入成功並且看到畫面了！（淚）\n","date":"2021-09-04T00:00:00Z","image":"https://yen0304.github.io/p/spring-security2%E4%BD%BF%E7%94%A8spring-security%E8%87%AA%E5%AE%9A%E7%BE%A9%E4%BD%BF%E7%94%A8%E8%80%85%E5%B8%B3%E5%AF%86%E4%BD%BF%E7%94%A8jdbc%E4%B8%B2%E6%8E%A5%E8%B3%87%E6%96%99%E5%BA%AB/logo_huf957eb7cc0803733802fcc4099cfd7cb_45239_120x120_fill_q75_box_smart1.jpeg","permalink":"https://yen0304.github.io/p/spring-security2%E4%BD%BF%E7%94%A8spring-security%E8%87%AA%E5%AE%9A%E7%BE%A9%E4%BD%BF%E7%94%A8%E8%80%85%E5%B8%B3%E5%AF%86%E4%BD%BF%E7%94%A8jdbc%E4%B8%B2%E6%8E%A5%E8%B3%87%E6%96%99%E5%BA%AB/","title":"Spring Security(2)使用Spring Security自定義使用者帳密、使用JDBC串接資料庫"},{"content":"什麼是Spring Security ？ Spring Security 是一個安全框架，\n在安全方面有兩個核心機制：驗證（authentication），大致上就是指系統去認證使用者是否能登入，授權（authorization）就是給予用戶權限去做某些特定的操作。\n簡單實作了解實際功用 下面示範Spring Security的實際作用，只需幾個步驟就可以解決！\nMaven設定 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-security\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; 設計Controller @RestController public class TestController { @RequestMapping(\u0026#34;/test123\u0026#34;) public String test() { return \u0026#34;安安123\u0026#34;; } 實際運行結果 這樣就可以執行了，但是一般來說，我們輸入localhost:8080/test123時，應該會出現方法的回傳訊息\u0026quot;安安123\u0026quot;，但當我們將網頁導向localhost:8080/test會出現下面這張照片：\n 要求登入畫面 \n在Spring Security中，預設的帳號是user，密碼則是可以從後台的console看到\n 密碼地方 \n所以帳號輸入：user 密碼則輸入程式運行時給的密碼，就能成功看到畫面：\n \n在這嘗試玩之後個人有使用APItester做get測試，結果會回傳401錯誤，如下圖：\n \n到這邊就差不多了解到了Spring Security 的作用之處了，期待日後的學習能更順利～！。\n","date":"2021-09-02T00:00:00Z","image":"https://yen0304.github.io/p/spring-security1%E8%AA%8D%E8%AD%98spring-security%E5%BE%AE%E6%BC%94%E7%B7%B4/logo_huf957eb7cc0803733802fcc4099cfd7cb_45239_120x120_fill_q75_box_smart1.jpeg","permalink":"https://yen0304.github.io/p/spring-security1%E8%AA%8D%E8%AD%98spring-security%E5%BE%AE%E6%BC%94%E7%B7%B4/","title":"Spring Security(1)認識Spring Security＆微演練"},{"content":"本文章涉及的知識  Springboot 、 Spring MVC HTTP method RESTful API JDBC mySQL語法 Html、css（小部分） Javascript 、Jquery、vue（小部分）  上一次的進度 [Spring Boot 管理會員資料（一）-會員創建](https://yen0304.github.io/p/spring-boot-%E7%AE%A1%E7%90%86%E6%9C%83%E5%93%A1%E8%B3%87%E6%96%99%E4%B8%80-%E6%9C%83%E5%93%A1%E5%89%B5%E5%BB%BA/#%E8%B3%87%E6%96%99%E5%BA%AB%E9%80%A3%E7%B7%9A%E8%A8%AD%E5%AE%9A-%E4%BD%BF%E7%94%A8jdbc)\n上次的進度用到了CRUD操作中的Create,創建了會員資料，這次就做完剩下的Read、Update、Delete功能，所以HTTP method以及RESTful API的部分請參照上一章節\n為了閱讀方便，附上一些本章節會使用到的資訊\nMember Class:\npublic class Member { Integer id; @NotBlank String name; @NotBlank String account; @NotBlank String password; //Getter\u0026amp;Setter  } 本章節Dao Interface、Service Dao＆Implement Dao public interface MemberDao { //返回值 依據名稱對應資料庫動作（參數類型 參數名稱）  String CreatMember(Member member); List\u0026lt;Member\u0026gt; ReadMember(); List\u0026lt;Member\u0026gt; ReadByAccount(String membersAccount); String UpdateByAccount(String membersAccount,Member member); String DeleteByAccount(String membersAccount); } Service public interface MemberService { String CreatMember(Member member); List\u0026lt;Member\u0026gt; ReadMember(); List\u0026lt;Member\u0026gt; ReadByAccount(String membersAccount); String DeleteByAccount(String membersAccount); String UpdateByAccount(String membersAccount,Member member); } ServiceImpl @Component public class MemberServiceImpl implements MemberService{ @Autowired//使用InterFace 發揮spring Ioc特性  private MemberDao memberDao; @Override public String CreatMember(Member member) { return memberDao.CreatMember(member); } @Override public List\u0026lt;Member\u0026gt; ReadMember() { return memberDao.ReadMember(); } @Override public List\u0026lt;Member\u0026gt; ReadByAccount(String membersAccount) { return memberDao.ReadByAccount(membersAccount); } @Override public String DeleteByAccount(String membersAccount) { return memberDao.DeleteByAccount(membersAccount); } @Override public String UpdateByAccount(String membersAccount,Member member) { return memberDao.UpdateByAccount(membersAccount,member); } } CRUD -Read Read-所有會員資料 在進行Read操作時，在sql是使用SELECT語法，所以在JDBC裡面是使用Query，在query中，會用到RowMapper參數，這個RowMapper的功能就是將資料庫查詢出來的數據轉會成我們要的Java Object。\nMemberRowMapper設計 public class MemberRowMapper implements RowMapper\u0026lt;Member\u0026gt; { @Override public Member mapRow(ResultSet resultSet, int i) throws SQLException { //ResultSet resultSet = 從資料庫中查詢出來的數據  Member member=new Member(); member.setId(resultSet.getInt(\u0026#34;id\u0026#34;)); member.setName(resultSet.getString(\u0026#34;name\u0026#34;)); member.setAccount(resultSet.getString(\u0026#34;account\u0026#34;)); member.setPassword(resultSet.getString(\u0026#34;password\u0026#34;)); return member; //返回值= 要轉換的Java Object  } } Dao設計 @Override //重要！當方法返回類型為自定義class,spring boot再返回時會自動轉換為json格式 public List\u0026lt;Member\u0026gt; ReadMember() { //query(放要執行sql的語法,放spl語法裡面變數的值,將資料查詢出來的數據轉換成java object)  //SELECT id, name...這邊是想要查詢的數據，不要用SELECT * FROM 查詢所有數據，很浪費流量  String sql=\u0026#34;SELECT id, name ,password ,account FROM member\u0026#34;; Map\u0026lt;String,Object\u0026gt;map= new HashMap\u0026lt;\u0026gt;(); List\u0026lt;Member\u0026gt; list =namedParameterJdbcTemplate.query(sql,map,new MemberRowMapper()); return list; } Controller @GetMapping(\u0026#34;/members\u0026#34;) //讀取所有會員資料 public List\u0026lt;Member\u0026gt; read(){ return memberService.ReadMember(); } HTML \u0026amp; Javascript HTML方面就是創造一行表格，其他下面的資料交給Vue來自動產生\n\u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34; \u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;顯示會員資料\u0026lt;/title\u0026gt; \u0026lt;link rel=\u0026#39;stylesheet\u0026#39; href=\u0026#39;https://cdn.jsdelivr.net/npm/bootstrap@5.0.0/dist/css/bootstrap.min.css\u0026#39;\u0026gt;\u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;/css/allmemberdatastyle.css\u0026#34;\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;!-- partial:index.partial.html --\u0026gt; \u0026lt;div id=\u0026#34;memberlist\u0026#34;\u0026gt; \u0026lt;h1\u0026gt;會員資料\u0026lt;/h1\u0026gt; \u0026lt;table class=\u0026#34;table table-striped table-info\u0026#34;\u0026gt; \u0026lt;thead\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;th scope=\u0026#34;col\u0026#34;\u0026gt;id\u0026lt;/th\u0026gt; \u0026lt;th scope=\u0026#34;col\u0026#34;\u0026gt;名稱\u0026lt;/th\u0026gt; \u0026lt;th scope=\u0026#34;col\u0026#34;\u0026gt;帳號\u0026lt;/th\u0026gt; \u0026lt;th scope=\u0026#34;col\u0026#34;\u0026gt;密碼\u0026lt;/th\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;/thead\u0026gt; \u0026lt;tbody id=\u0026#34;databody\u0026#34;\u0026gt;\u0026lt;/tbody\u0026gt; \u0026lt;/table\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;!-- partial --\u0026gt; \u0026lt;script src=\u0026#39;https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js\u0026#39;\u0026gt;\u0026lt;/script\u0026gt;\u0026lt;script src=\u0026#34;/js/allmemberdatascript.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Javascript\n這裡在定義自動生成的html時加上了各個資料的css class名稱，目的是為了在使用JQuery時能順利抓到資料。\n//新增物件 var memberlist={}; //如果要測試的話這裡可以先填上Json資料 var apiurl=\u0026#34;/members\u0026#34;; //定義自動生成的html （資料） var list_html=\u0026#34;\u0026lt;tr\u0026gt;\u0026lt;th class=\u0026#39;id \u0026#39;scope=\u0026#39;col\u0026#39;\u0026gt;{{id}}\u0026lt;/th\u0026gt;\u0026lt;th class=\u0026#39;name \u0026#39;scope=\u0026#39;col\u0026#39;\u0026gt;{{name}}\u0026lt;/th\u0026gt;\u0026lt;th class=\u0026#39;account\u0026#39; scope=\u0026#39;col\u0026#39;\u0026gt;{{account}}\u0026lt;/th\u0026gt;\u0026lt;th class=\u0026#39;password \u0026#39;scope=\u0026#39;col\u0026#39;\u0026gt;{{password}}\u0026lt;/th\u0026gt;\u0026lt;th scope=\u0026#39;col\u0026#39;\u0026gt; \u0026lt;button class=\u0026#39;btn btn-primary edit\u0026#39; type=\u0026#39;button\u0026#39;\u0026gt;編輯\u0026lt;/button\u0026gt;\u0026lt;button class=\u0026#39;btn btn-danger remove\u0026#39; type=\u0026#39;button\u0026#39;\u0026gt;刪除\u0026lt;/button\u0026gt;\u0026lt;/th\u0026gt;\u0026lt;/tr\u0026gt;\u0026#34;; $.ajax({ url: apiurl, dataType:\u0026#34;json\u0026#34;, success:function(res){ memberlist.list=(res); for(var i=0;i\u0026lt;memberlist.list.length;i++){ var current_html= list_html.replace(\u0026#34;{{id}}\u0026#34;,memberlist.list[i].id) .replace(\u0026#34;{{name}}\u0026#34;,memberlist.list[i].name) .replace(\u0026#34;{{account}}\u0026#34;,memberlist.list[i].account) .replace(\u0026#34;{{password}}\u0026#34;,memberlist.list[i].password); //memberlist.list[i]代表後端回傳Json格式中的第i筆數據, .xxx代表資料名稱  $(\u0026#34;#databody\u0026#34;).append(current_html); } } }); 結果：\n \nRead-依據帳號查詢 方法跟查詢所有資料幾乎一樣，用了一樣的RowMapper等等，唯一不同的就是SQL語法部分\nDAO 整理一下差別：\n查詢所有資料：\nString sql=\u0026quot;SELECT id, name ,password ,account FROM member \u0026quot;;\n依據帳號查詢：\nString sql=\u0026quot;SELECT id, name ,password ,account FROM member WHERE account=:memberAccount\u0026quot;;\n@Override public List\u0026lt;Member\u0026gt; ReadByAccount(String membersAccount) { String sql=\u0026#34;SELECT id, name ,password ,account FROM member WHERE account=:memberAccount\u0026#34;; Map\u0026lt;String,Object\u0026gt;map= new HashMap\u0026lt;\u0026gt;(); map.put(\u0026#34;memberAccount\u0026#34;,membersAccount); List\u0026lt;Member\u0026gt; list =namedParameterJdbcTemplate.query(sql,map,new MemberRowMapper()); return list; } Controller @GetMapping(\u0026#34;members/{membersAccount}\u0026#34;) //根據帳號做查詢 public List\u0026lt;Member\u0026gt; read(@PathVariable String membersAccount){ return memberService.ReadByAccount(membersAccount); }  \nCRUD -Update 這裡在實作的時候想了一下，傳遞的參數內容，先確認call api的時候果然put method有BODY可以放Json資料，所以設計上就是收到前端傳來的Json格式之後，再依據URL做帳號資料修改。\nDAO\n@Override public String UpdateByAccount(String membersAccount,Member member) { String sql =\u0026#34;UPDATE member SET name=:memberName,password=:memberPassword WHERE account=:memberAccount\u0026#34;; Map\u0026lt;String, Object\u0026gt; map =new HashMap\u0026lt;\u0026gt;(); //put(SQL變數,值）  map.put(\u0026#34;memberName\u0026#34;,member.getName()); map.put(\u0026#34;memberAccount\u0026#34;,membersAccount); map.put(\u0026#34;memberPassword\u0026#34;,member.getPassword()); namedParameterJdbcTemplate.update(sql,map); return \u0026#34;修改成功\u0026#34;; } Controller\n@PutMapping(\u0026#34;members/{membersAccount}\u0026#34;) //根據帳號做修改 public String update(@PathVariable String membersAccount,@RequestBody Member member){ //@Path用來取得url路徑的值  return memberService.UpdateByAccount(membersAccount,member); } 結果：\n \n資料庫數據成功修改：\n \nCRUD -Delete 會前面的這裡應該就沒什麼問題了\nDao @Override public String DeleteByAccount(String membersAccount) { String sql =\u0026#34;DELETE FROM member WHERE account = :membersAccount\u0026#34;; Map\u0026lt;String,Object\u0026gt;map= new HashMap\u0026lt;\u0026gt;(); map.put(\u0026#34;membersAccount\u0026#34;,membersAccount); namedParameterJdbcTemplate.update(sql,map); return \u0026#34;刪除成功\u0026#34;; } Controller @DeleteMapping(\u0026#34;members/{membersAccount}\u0026#34;) //根據帳號做刪除 public String delete(@PathVariable String membersAccount){ //@Path用來取得url路徑的值  return memberService.DeleteByAccount(membersAccount); } Javascript html跟查詢所有帳號的一樣,所以js檔案是同一個，在產生清單資料時按鈕加上了.remove 定義了刪除的class，在使用document去監聽事件觸發\n$(document).on(\u0026#34;click\u0026#34;,\u0026#39;.remove\u0026#39;,function(){ console.log($(this).parent().parent().children(\u0026#39;.account\u0026#39;).text()); $.ajax({ type: \u0026#39;DELETE\u0026#39;, url:apiurl + \u0026#39;/\u0026#39; + $(this).parent().parent().children(\u0026#39;.account\u0026#39;).text(), success: function(){ $(this).parent().parent().remove(); window.location.reload();//刪除後重新整理視窗  } }); 刪除結果就是資料不見了，應該就沒辦法展示了，哈。\nGitHub 直接附上GitHub，希望對各位有幫助，一方面自己之後要用也不用怕丟失啦～\n檔案連結\n","date":"2021-08-28T00:00:00Z","image":"https://yen0304.github.io/p/spring-boot-%E7%AE%A1%E7%90%86%E6%9C%83%E5%93%A1%E8%B3%87%E6%96%99%E4%BA%8C-crud%E4%B9%8Brud%E6%93%8D%E4%BD%9C/cover_hu3d03a01dcc18bc5be0e67db3d8d209a6_702789_120x120_fill_q75_box_smart1.jpg","permalink":"https://yen0304.github.io/p/spring-boot-%E7%AE%A1%E7%90%86%E6%9C%83%E5%93%A1%E8%B3%87%E6%96%99%E4%BA%8C-crud%E4%B9%8Brud%E6%93%8D%E4%BD%9C/","title":"Spring Boot 管理會員資料（二）-CRUD之RUD操作"},{"content":"本文章涉及的知識  Springboot 、 Spring MVC HTTP method RESTful API JDBC mySQL語法 Html、css（小部分） Javascript 、Jquery（小部分）  複習HTPP method-GET or POST 差別 GET 或 POST 的差別最大的差別在於傳遞的參數會被看見，因為參數會放在url裡面。\nPOST的話參數會放在request body裡面，request body裡面通常會用Json格式來進行前後端的溝通\n在Spring Boot裡面，使用@RequestBody取得放在request body的參數\n練習設計RESTful API RESTful API三大原則： 1.使用http method表示動作\n   HTTP Method 對應資料動作     POST Create（新增）   GET Read（查詢）   PUT Update（修改）   DELETE Delete（刪除）    2.url路徑表示資源階層關係\n3.response body返回json或是xml格式\n設計本範例RESTful API 設計會員資料之class public class Member { Integer id; String name; String account; String password; //getter \u0026amp; setter }    Method Url 資料庫 意義     POST /members Create（新增） 創建會員   GET /members/abc123 Read（查詢） 查詢會員帳號為abc123的資料   PUT /members/abc123 Update（修改） 修改會員帳號為abc123的資料   DELETE /members/abc123 Delete（刪除） 刪除會員帳號為abc123的資料    驗證請求參數 @NotBlank 為了讓使用者的登入數值不能為空白，避免後端程式發生錯誤，可以用此方法提前一部將錯誤回報給前端。\n1.maven設定（2.3.X)版本之後才需要設定\n\u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-validation\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; 2.用途\n在數值上加入＠NotBlank代表參數不能為空、且不能為空白字串，@NotBlank只能放在String類型參數上面，若需要用在Integer上面，可使用@NotEmpty或是@NotNull。\npublic class Member { Integer id; @NotBlank String name; @NotBlank String account; @NotBlank String password; //getter\u0026amp;setter } 資料庫連線設定 使用JDBC 1.maven設定\n\u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-jdbc\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- https://mvnrepository.com/artifact/mysql/mysql-connector-java --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;mysql\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;mysql-connector-java\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;8.0.22\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 2.設定SpringBoot連線資訊（固定寫法），到application.properties\nspring.datasource.driver-class-name=com.mysql.cj.jdbc.Driverspring.datasource.url=jdbc:mysql://localhost:3306/mytest?serverTimezone=Asia/Taipei\u0026amp;characterEncoding=utf-8spring.datasource.username=rootspring.datasource.password=********3.複習一下在JDBC中的語法：\n根據sql語法可分成兩類，分別為update()與query()，其中update可執行INSERT、UPDATE、SELETE語法，query則是執行SELECT語法\n資料庫設定 CREATETABLEmember(idINTPRIMARYKEYAUTO_INCREMENT,nameVARCHAR(30),accountVARCHAR(30),passwordVARCHAR(30))進入spring MVC環節 物件member public class Member { Integer id; String name; String account; String password; //getter\u0026amp;setter } 設計DAO-負責與資料庫溝通 介面：\npublic interface MemberDao { //返回值 依據名稱對應資料庫動作（參數類型 參數名稱）  String CreatMember(Member member); } 實作：\n@Component //將class交給Bean public class MemberDaoImpl implements MemberDao{ @Autowired private NamedParameterJdbcTemplate namedParameterJdbcTemplate; @Override public String CreatMember(Member member) { String sql =\u0026#34;INSERT INTO member(name,account,password)VALUE(:memberName,:memberAccount,:memberPassword)\u0026#34;;// 在SQL前面加上：表示變數  Map\u0026lt;String, Object\u0026gt; map =new HashMap\u0026lt;\u0026gt;(); map.put(\u0026#34;memberId\u0026#34;,member.getId()); //put(SQL變數,值）  map.put(\u0026#34;memberName\u0026#34;,member.getName()); map.put(\u0026#34;memberAccount\u0026#34;,member.getAccount()); map.put(\u0026#34;memberPassword\u0026#34;,member.getPassword()); namedParameterJdbcTemplate.update(sql,map); return \u0026#34;註冊成功\u0026#34;; //return放將來要使用的html  } 設計Service-負責商業邏輯 介面：\npublic interface MemberService { String CreatMember(Member member); } 實作：\n@Component public class MemberServiceImpl implements MemberService{ @Autowired//使用InterFace 發揮spring Ioc特性  private MemberDao memberDao; @Override public String CreatMember(Member member) { return memberDao.CreatMember(member); } } 設計Controller @RestController public class MemberController { @Autowired //注入bean 使用jdbc執行 MySQL資料庫操作  private NamedParameterJdbcTemplate namedParameterJdbcTemplate; @Autowired private MemberService memberService; @PostMapping(\u0026#34;/members\u0026#34;) //設置url路徑對應到此方法上，並限制只能使用Post方法,  public String create(@RequestBody Member member){ //使用@RequestBody取得前端requestBody資訊  return memberService.CreatMember(member); } } 其實在這邊遇到了不少難題，\n本來預計的流程是，想說使用@Postmapping後頁面自動跳轉到結果頁面（return值為ftl)，遇到了PostMapping回傳值為html頁面無法跳轉問題，發現＠ResponseBody＠RequestBody＠RestController要搞清楚之外，經由老師古古說指導後發現此方法無法將前後端完全分離，應該由後端傳回Json格式的檔案之後，在使用前端去顯示結果。\n＠Controller+＠ResponseBody=＠RestController：用於回傳Json檔案給前端使用\n＠RequestBody：用於接收前端的Json格式\n在途中嘗試了不少次，回傳數值必須不能為純String或是html，要用加上註解的＠RestController讓回傳值變成Json，這樣前端才能順利收到數值，並狀態碼為200，（之後再研究看看是為什麼）。\nHTML \u0026amp; Javascript 這邊用到了一點點的Jquery取得變數，以及$.post請求，不能用$.ajax，因為ajax不能挑轉頁面\nHTML \u0026lt;body\u0026gt; \u0026lt;!-- partial:index.partial.html --\u0026gt; \u0026lt;div class=\u0026#34;main-form first\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;main-form__title\u0026#34;\u0026gt; \u0026lt;h1\u0026gt;Sign-up\u0026lt;/h1\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;main-form__body\u0026#34;\u0026gt; \u0026lt;input id=\u0026#34;name\u0026#34; class=\u0026#34;main-form__input\u0026#34; type=\u0026#34;text\u0026#34; placeholder=\u0026#34;Username\u0026#34; /\u0026gt; \u0026lt;input id=\u0026#34;account\u0026#34; class=\u0026#34;main-form__input\u0026#34; type=\u0026#34;email\u0026#34; placeholder=\u0026#34;Email Address\u0026#34; /\u0026gt; \u0026lt;input id=\u0026#34;password\u0026#34; class=\u0026#34;main-form__input\u0026#34; type=\u0026#34;password\u0026#34; placeholder=\u0026#34;Password\u0026#34;/\u0026gt; \u0026lt;input class=\u0026#34;main-form__input\u0026#34; type=\u0026#34;password\u0026#34; placeholder=\u0026#34;Repeat Password\u0026#34; /\u0026gt; \u0026lt;button class=\u0026#34;btn\u0026#34;\u0026gt;Clear\u0026lt;/button\u0026gt; \u0026lt;button id=\u0026#34;enter\u0026#34; class=\u0026#34;btn\u0026#34;\u0026gt;Register\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;!-- partial --\u0026gt; \u0026lt;script src=\u0026#39;https://cdnjs.cloudflare.com/ajax/libs/bootstrap/5.0.0/js/bootstrap.min.js\u0026#39;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script src=\u0026#39;https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js\u0026#39;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script src=\u0026#34;https://cdnjs.cloudflare.com/ajax/libs/vue/2.6.11/vue.min.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script src=\u0026#34;/js/script.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; Javascript var apiurl={ registerdata:\u0026#34;/members\u0026#34;, successregister:\u0026#34;/display.html\u0026#34; } $(\u0026#34;#enter\u0026#34;).click(function (){ var name = $(\u0026#34;#name\u0026#34;).val(); var account = $(\u0026#34;#account\u0026#34;).val(); var password = $(\u0026#34;#password\u0026#34;).val(); $.post({ url:apiurl.registerdata, contentType:\u0026#34;application/json;charset=UTF-8\u0026#34;, data:JSON.stringify({\u0026#34;name\u0026#34;:name,\u0026#34;account\u0026#34;:account,\u0026#34;password\u0026#34;:password}), success:function(res) { window.location.href = apiurl.successregister;//正確登入後頁面跳轉  } }); }); 檔案路徑配置 將首頁放在templates裡面，並取名為index，其餘分頁靜態的放static底下就好\n \n結果 1.上網找的前端頁面（自己懶得寫ＸＤ）\n index.html \n2.完成後跳到display頁面，\n 結果畫面 \n3.資料庫數據：\n 資料庫數據（intelij) \n","date":"2021-08-20T00:00:00Z","image":"https://yen0304.github.io/p/spring-boot-%E7%AE%A1%E7%90%86%E6%9C%83%E5%93%A1%E8%B3%87%E6%96%99%E4%B8%80-%E6%9C%83%E5%93%A1%E5%89%B5%E5%BB%BA-crud-create/cover_hu3d03a01dcc18bc5be0e67db3d8d209a6_702789_120x120_fill_q75_box_smart1.jpg","permalink":"https://yen0304.github.io/p/spring-boot-%E7%AE%A1%E7%90%86%E6%9C%83%E5%93%A1%E8%B3%87%E6%96%99%E4%B8%80-%E6%9C%83%E5%93%A1%E5%89%B5%E5%BB%BA-crud-create/","title":"Spring Boot 管理會員資料（一）-會員創建 CRUD-Create"},{"content":"前言 Springboot + Freemaker 基本設置 前端複習的差不多了，所以來試試如何將後端數據傳到前，在google的幫助下，瞭解了要用搜尋關鍵字Springboot + Freemaker，Freemaker 跟thymeleaf是差不多功能的東西，雖然Springboot官方是推薦使用thymeleaf，但網路上比較上是Freemaker勝出，且在設定上好像較容易，所以就使用Freemaker作為模板引擎了\n在網路上的資源很多，從官方到個人網站都有教學，大同小異，但是到了最後連結上還是出了小問題，幸好最終解決了，所以在這紀錄一下架設過程，希望大家需要時能按圖施工保證成功！！\n環境介紹 開發平台：IntelliJ 2020.3\nSpringboot版本：2.3.7.release\n前端：html、css、皆快速使用bootstrap\n1.maven添加Freemaker \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-freemarker\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; 2.檔案路徑\u0026amp;Freemaker環境配置 接下來檔案路徑就很重要了，\n步驟1.\n將自己index.html檔案放在resources/templates裡面，步驟是將檔案拉進去resources/templates後，intellij會詢問檔案名稱，這時候把副檔名改成ftl\n接著要修改模板預設參數，在application.properties裡打上以下程式碼\nspring.freemarker.cache=false# 模版後綴名 默認為ftlspring.freemarker.suffix=.ftl# 文件編碼spring.freemarker.charset=UTF-8# 模版加載的目錄spring.freemarker.template-loader-path=classpath:/templates/步驟2.\ncss、js檔案放在resources/static底下，切記，**一定要在static下新增css以及js資料夾！**否則會無法成功取得（我就是在這邊卡很久）。\n3.測試用程式碼 接著新增controller,並使用getmapping\n如下：\n@Controller public class Logincontroller { @GetMapping(\u0026#34;/page\u0026#34;) public String show(Model model) { model.addAttribute(\u0026#34;name\u0026#34;,\u0026#34;測試\u0026#34;); return \u0026#34;/index\u0026#34;; } } 這邊要注意的地方是，\nreturn \u0026#34;/index\u0026#34;; return的值就是ftl的檔案名稱\n接著到index.ftl到隨便一個地方 加入 ${name} 來測試\n我的長這樣：\n\u0026lt;label\u0026gt; \u0026lt;input type=\u0026#34;checkbox\u0026#34; value=\u0026#34;remember-me\u0026#34;/\u0026gt; ${name} \u0026lt;/label\u0026gt; 4.檔案結構＆成果 這邊附上完整的檔案路徑配置\n \n運行成果：\n \n","date":"2021-08-08T00:00:00Z","image":"https://yen0304.github.io/p/spingboot-freemarker%E5%9F%BA%E6%9C%AC%E9%85%8D%E7%BD%AE/post_hu3cf4b63e80cf49258a3cdf19be741597_1490134_120x120_fill_q75_box_smart1.jpg","permalink":"https://yen0304.github.io/p/spingboot-freemarker%E5%9F%BA%E6%9C%AC%E9%85%8D%E7%BD%AE/","title":"Spingboot+Freemarker基本配置"}]